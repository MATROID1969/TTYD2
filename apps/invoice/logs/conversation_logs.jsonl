{"timestamp": "2026-02-18T15:58:26.456390", "event": "question_run", "previous_question": null, "user_input": "Melyik ügyfélnek volt 2025-ben legtöbb késve fizetett számlája? ", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Melyik ügyfélnek volt 2025-ben legtöbb késve fizetett számlája? ", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nimport pandas as pd\n\nYEAR = 2025\nMIN_DELAY_DAYS = 1\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\ndf_tmp = df_tmp[\n    df_tmp[\"customer_name\"].notna() &\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna()\n].copy()\n\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].dt.year == YEAR\n].copy()\n\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\ndf_tmp[\"kesedelmes\"] = df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n\ncounts = (\n    df_tmp[df_tmp[\"kesedelmes\"]]\n    .groupby(\"customer_name\")\n    .size()\n    .sort_values(ascending=False)\n)\n\nif len(counts) == 0:\n    result = {\"ugyfel\": None, \"kesedelmes_szamlak_szama\": 0}\nelse:\n    top_customer = str(counts.index[0])\n    top_count = int(counts.iloc[0])\n    result = {\n        \"ugyfel\": top_customer,\n        \"kesedelmes_szamlak_szama\": top_count\n    }"}
{"timestamp": "2026-02-18T16:10:36.665503", "event": "question_run", "previous_question": null, "user_input": "Melyik ügyfélnek volt 2025-ben legtöbb késve fizetett számlája? ", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Melyik ügyfélnek volt 2025-ben legtöbb késve fizetett számlája? ", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nimport pandas as pd\n\nYEAR = 2025\nMIN_DELAY_DAYS = 1\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\ndf_tmp = df_tmp[\n    df_tmp[\"customer_name\"].notna() &\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna()\n].copy()\n\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].dt.year == YEAR\n].copy()\n\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\ndf_tmp[\"kesedelmes\"] = df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n\ncounts = (\n    df_tmp[df_tmp[\"kesedelmes\"]]\n    .groupby(\"customer_name\")\n    .size()\n)\n\nif len(counts) == 0:\n    result = {\"ugyfel\": None, \"kesve_fizetett_szamlak_szama\": 0}\nelse:\n    top_customer = str(counts.idxmax())\n    top_count = int(counts.max())\n    result = {\n        \"ugyfel\": top_customer,\n        \"kesve_fizetett_szamlak_szama\": top_count\n    }"}
{"timestamp": "2026-02-18T16:12:13.763064", "event": "question_run", "previous_question": "Melyik ügyfélnek volt 2025-ben legtöbb késve fizetett számlája? ", "user_input": "Rajzolj egy oszlop diagramot, hogy a Danube Digital cégnek havonta hány számlája volt 2025-ben és egy vonal diagram mutassa, hogy az adott havi számlák közül hány százalék volt késve fizetve! ", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Rajzolj egy oszlop diagramot, hogy a Danube Digital cégnek havonta hány számlája volt 2025-ben és egy vonal diagram mutassa, hogy az adott havi számlák közül hány százalék volt késve fizetve! ", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nimport pandas as pd\n\n# Paraméterek\nYEAR = 2025\nQUERY_NAME = \"Danube Digital\"\nMIN_DELAY_DAYS = 1  # késedelmes = legalább 1 nap\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak 2025-ös számlák, értelmezhető vevőnév\ndf_tmp = df_tmp[\n    (df_tmp[\"posting_date\"].dt.year == YEAR) &\n    (df_tmp[\"customer_name\"].notna())\n].copy()\n\n# Entitásfeloldás (KÖTELEZŐ)\ncandidates = sorted(df_tmp[\"customer_name\"].dropna().unique().tolist())\nresolved_name = resolve_entity(QUERY_NAME, candidates)\n\nif resolved_name is None:\n    result = {\n        \"message\": \"Nem található a megadott névhez illeszkedő ügyfél.\",\n        \"keresett_nev\": QUERY_NAME,\n        \"hasonlo_nevek\": candidates[:10]\n    }\nelse:\n    df_cust = df_tmp[df_tmp[\"customer_name\"] == resolved_name].copy()\n    if len(df_cust) == 0:\n        result = {\n            \"message\": \"A megadott ügyfélnek nincs számlája 2025-ben.\",\n            \"ugyfel\": resolved_name\n        }\n    else:\n        # Hónap képzése\n        df_cust[\"Honap\"] = df_cust[\"posting_date\"].dt.to_period(\"M\").dt.to_timestamp()\n\n        # Késés napokban (csak ahol van határidő és kifizetés)\n        mask_delay = df_cust[\"due_in_date\"].notna() & df_cust[\"clear_date\"].notna()\n        df_cust.loc[mask_delay, \"delay_days\"] = kesedelmes_napok(\n            df_cust.loc[mask_delay, \"due_in_date\"],\n            df_cust.loc[mask_delay, \"clear_date\"]\n        )\n        df_cust[\"kesedelmes\"] = False\n        df_cust.loc[mask_delay, \"kesedelmes\"] = df_cust.loc[mask_delay, \"delay_days\"] >= MIN_DELAY_DAYS\n\n        # Havi aggregáció\n        monthly = (\n            df_cust\n            .groupby(\"Honap\")\n            .agg(\n                szamlak_szama=(\"invoice_id\", \"count\"),\n                kesedelmes_szamlak=(\"kesedelmes\", \"sum\")\n            )\n            .reset_index()\n        )\n        monthly[\"kesedelmes_pct\"] = (\n            monthly[\"kesedelmes_szamlak\"] / monthly[\"szamlak_szama\"] * 100\n        ).round(2)\n\n        # Diagram\n        fig, ax1 = plt.subplots(figsize=(8,3))\n\n        # Oszlopdiagram: számlák száma\n        ax1.bar(\n            monthly[\"Honap\"],\n            monthly[\"szamlak_szama\"],\n            width=20,\n            color=\"#4B8BBE\",\n            label=\"Számlák száma\"\n        )\n        ax1.set_ylabel(\"Számlák száma\")\n        ax1.set_xlabel(\"Hónap\")\n        ax1.xaxis.set_major_formatter(\n            FuncFormatter(lambda x, _: pd.to_datetime(x).strftime(\"%Y-%m\") if pd.notna(x) else \"\")\n        )\n        ax1.tick_params(axis=\"y\")\n        ax1.set_title(f\"{resolved_name} – 2025 havi számlaszám és késedelmes arány\")\n\n        # Vonaldiagram: késedelmes arány (%)\n        ax2 = ax1.twinx()\n        ax2.plot(\n            monthly[\"Honap\"],\n            monthly[\"kesedelmes_pct\"],\n            color=\"#E06C75\",\n            marker=\"o\",\n            label=\"Késedelmes arány (%)\"\n        )\n        ax2.set_ylabel(\"Késedelmes arány (%)\")\n        ax2.set_ylim(0, 100)\n        ax2.tick_params(axis=\"y\")\n\n        # Jelmagyarázat\n        lines1, labels1 = ax1.get_legend_handles_labels()\n        lines2, labels2 = ax2.get_legend_handles_labels()\n        ax1.legend(lines1 + lines2, labels1 + labels2, loc=\"upper left\")\n\n        result = fig"}
{"timestamp": "2026-02-18T16:13:01.206459", "event": "question_run", "previous_question": "Rajzolj egy oszlop diagramot, hogy a Danube Digital cégnek havonta hány számlája volt 2025-ben és egy vonal diagram mutassa, hogy az adott havi számlák közül hány százalék volt késve fizetve! ", "user_input": "Ne legyen benne rácsvonal", "gate_decision": "FOLLOWUP", "rewritten_question": "Rajzolj egy olyan oszlopdiagramot, amely megmutatja, hogy a Danube Digital cégnek havonta hány számlája volt 2025-ben, és egy vonaldiagramot, amely az adott havi számlák közül a késve fizetett számlák százalékát mutatja, mindezt rácsvonalak nélkül!", "final_question": "Rajzolj egy olyan oszlopdiagramot, amely megmutatja, hogy a Danube Digital cégnek havonta hány számlája volt 2025-ben, és egy vonaldiagramot, amely az adott havi számlák közül a késve fizetett számlák százalékát mutatja, mindezt rácsvonalak nélkül!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nimport pandas as pd\n\n# Paraméterek\nYEAR = 2025\nQUERY_NAME = \"Danube Digital\"\nMIN_DELAY_DAYS = 1\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak 2025-ös számlák, értelmezhető vevőnév\ndf_tmp = df_tmp[\n    (df_tmp[\"posting_date\"].dt.year == YEAR) &\n    (df_tmp[\"customer_name\"].notna())\n].copy()\n\n# Entitásfeloldás\ncandidates = sorted(df_tmp[\"customer_name\"].dropna().unique().tolist())\nresolved_name = resolve_entity(QUERY_NAME, candidates)\n\nif resolved_name is None:\n    result = {\n        \"message\": \"Nem található a megadott névhez illeszkedő ügyfél.\",\n        \"keresett_nev\": QUERY_NAME,\n        \"hasonlo_nevek\": candidates[:10]\n    }\nelse:\n    df_cust = df_tmp[df_tmp[\"customer_name\"] == resolved_name].copy()\n    if len(df_cust) == 0:\n        result = {\n            \"message\": \"A megadott ügyfélnek nincs számlája 2025-ben.\",\n            \"ugyfel\": resolved_name\n        }\n    else:\n        # Hónap képzése\n        df_cust[\"Honap\"] = df_cust[\"posting_date\"].dt.to_period(\"M\").dt.to_timestamp()\n\n        # Késés napokban (csak ahol van határidő és kifizetés)\n        mask_delay = df_cust[\"due_in_date\"].notna() & df_cust[\"clear_date\"].notna()\n        df_cust.loc[mask_delay, \"delay_days\"] = kesedelmes_napok(\n            df_cust.loc[mask_delay, \"due_in_date\"],\n            df_cust.loc[mask_delay, \"clear_date\"]\n        )\n        df_cust[\"kesedelmes\"] = False\n        df_cust.loc[mask_delay, \"kesedelmes\"] = df_cust.loc[mask_delay, \"delay_days\"] >= MIN_DELAY_DAYS\n\n        # Havi aggregáció\n        monthly = (\n            df_cust\n            .groupby(\"Honap\")\n            .agg(\n                szamlak_szama=(\"invoice_id\", \"count\"),\n                kesedelmes_szamlak=(\"kesedelmes\", \"sum\")\n            )\n            .reset_index()\n        )\n        monthly[\"kesedelmes_pct\"] = (\n            monthly[\"kesedelmes_szamlak\"] / monthly[\"szamlak_szama\"] * 100\n        ).fillna(0.0)\n\n        # Diagram\n        fig, ax1 = plt.subplots(figsize=(8,3))\n\n        # Oszlopdiagram: számlák száma\n        bars = ax1.bar(\n            monthly[\"Honap\"],\n            monthly[\"szamlak_szama\"],\n            color=\"#4B8BBE\",\n            width=20\n        )\n        ax1.set_ylabel(\"Számlák száma\", color=\"#4B8BBE\")\n        ax1.tick_params(axis=\"y\", labelcolor=\"#4B8BBE\")\n        ax1.xaxis.set_major_formatter(\n            FuncFormatter(lambda x, _: pd.to_datetime(x).strftime(\"%Y-%m\") if not pd.isna(x) else \"\")\n        )\n        ax1.yaxis.set_major_formatter(\n            FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \"))\n        )\n\n        # Vonaldiagram: késedelmes arány\n        ax2 = ax1.twinx()\n        ax2.plot(\n            monthly[\"Honap\"],\n            monthly[\"kesedelmes_pct\"],\n            color=\"#E06C75\",\n            linewidth=2\n        )\n        ax2.set_ylabel(\"Késve fizetett számlák aránya (%)\", color=\"#E06C75\")\n        ax2.tick_params(axis=\"y\", labelcolor=\"#E06C75\")\n        ax2.set_ylim(0, 100)\n\n        # Cím, tengelyek\n        ax1.set_title(f\"{resolved_name} – 2025 havi számlaszám és késedelmes arány\")\n        ax1.set_xlabel(\"Hónap\")\n\n        # Rácsvonalak kikapcsolása\n        ax1.grid(False)\n        ax2.grid(False)\n\n        result = fig"}
{"timestamp": "2026-02-18T16:35:38.072881", "event": "question_run", "previous_question": "Rajzolj egy olyan oszlopdiagramot, amely megmutatja, hogy a Danube Digital cégnek havonta hány számlája volt 2025-ben, és egy vonaldiagramot, amely az adott havi számlák közül a késve fizetett számlák százalékát mutatja, mindezt rácsvonalak nélkül!", "user_input": "\nVálogasd le Digital Danube azon számláit egy táblázatba, amelyek 10 napon túl lettek fizetve és a bruttó számla összege nagyobb volt 1.500.000 Ft-nál!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "\nVálogasd le Digital Danube azon számláit egy táblázatba, amelyek 10 napon túl lettek fizetve és a bruttó számla összege nagyobb volt 1.500.000 Ft-nál!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Paraméterek\nQUERY_NAME = \"Digital Danube\"\nMIN_DELAY_DAYS = 10\nMIN_BRUTTO = 1_500_000\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető vevő, bruttó, határidő, kifizetés dátum\ndf_tmp = df_tmp[\n    df_tmp[\"customer_name\"].notna() &\n    df_tmp[\"Brutto\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna()\n].copy()\n\n# Entitásfeloldás\ncandidates = sorted(df_tmp[\"customer_name\"].dropna().unique().tolist())\nresolved_name = resolve_entity(QUERY_NAME, candidates)\n\nif resolved_name is None:\n    result = {\n        \"message\": \"Nem található a megadott névhez illeszkedő ügyfél.\",\n        \"keresett_nev\": QUERY_NAME,\n        \"hasonlo_nevek\": candidates[:10]\n    }\nelse:\n    df_f = df_tmp[df_tmp[\"customer_name\"] == resolved_name].copy()\n    # Késés napokban\n    df_f[\"delay_days\"] = kesedelmes_napok(\n        df_f[\"due_in_date\"],\n        df_f[\"clear_date\"]\n    )\n    # Szűrés: késés + nagy összeg\n    df_res = df_f[\n        (df_f[\"delay_days\"] > MIN_DELAY_DAYS) &\n        (df_f[\"Brutto\"] > MIN_BRUTTO)\n    ].copy()\n    # Kimeneti táblázat\n    result = df_res[\n        [\n            \"invoice_nr\",\n            \"customer_name\",\n            \"posting_date\",\n            \"due_in_date\",\n            \"clear_date\",\n            \"Brutto\",\n            \"delay_days\"\n        ]\n    ].reset_index(drop=True)"}
{"timestamp": "2026-02-18T16:37:13.343851", "event": "question_run", "previous_question": "\nVálogasd le Digital Danube azon számláit egy táblázatba, amelyek 10 napon túl lettek fizetve és a bruttó számla összege nagyobb volt 1.500.000 Ft-nál!", "user_input": "\nMilyen Digital Danube névhez hasonló nevű cégek vannak a partberek között? ", "gate_decision": "NEW", "rewritten_question": null, "final_question": "\nMilyen Digital Danube névhez hasonló nevű cégek vannak a partberek között? ", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\n\n# Paraméter\nQUERY_NAME = \"Digital Danube\"\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Csak értelmezhető ügyfélnevek\ndf_tmp = df_tmp[df_tmp[\"customer_name\"].notna()].copy()\n\n# Kandidátus lista\ncandidates = sorted(df_tmp[\"customer_name\"].dropna().unique().tolist())\n\n# Entitásfeloldás\nresolved = resolve_entity(QUERY_NAME, candidates)\n\nif resolved is not None:\n    result = {\n        \"talalat\": resolved\n    }\nelse:\n    # Hasonló nevek keresése (fuzzy keresés)\n    import difflib\n    similar = difflib.get_close_matches(QUERY_NAME, candidates, n=10, cutoff=0.5)\n    result = {\n        \"message\": \"Nem található pontos egyezés.\",\n        \"keresett_nev\": QUERY_NAME,\n        \"hasonlo_nevek\": similar\n    }"}
{"timestamp": "2026-02-18T16:38:56.525931", "event": "question_run", "previous_question": "\nMilyen Digital Danube névhez hasonló nevű cégek vannak a partberek között? ", "user_input": "Válogasd le Danube Digital 654 Corp cég azon számláit egy táblázatba, amelyek 10 napon túl lettek fizetve és a bruttó számla összege nagyobb volt 1.500.000 Ft-nál!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Válogasd le Danube Digital 654 Corp cég azon számláit egy táblázatba, amelyek 10 napon túl lettek fizetve és a bruttó számla összege nagyobb volt 1.500.000 Ft-nál!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Paraméterek\nQUERY_NAME = \"Danube Digital 654 Corp\"\nMIN_DELAY_DAYS = 10\nMIN_BRUTTO = 1_500_000\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető vevő, dátumok, bruttó összeg\ndf_tmp = df_tmp[\n    df_tmp[\"customer_name\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\n# Entitásfeloldás (KÖTELEZŐ)\ncandidates = sorted(df_tmp[\"customer_name\"].dropna().unique().tolist())\nresolved_name = resolve_entity(QUERY_NAME, candidates)\n\nif resolved_name is None:\n    result = {\n        \"message\": \"Nem található a megadott névhez illeszkedő ügyfél.\",\n        \"keresett_nev\": QUERY_NAME,\n        \"hasonlo_nevek\": candidates[:10]\n    }\nelse:\n    df_f = df_tmp[df_tmp[\"customer_name\"] == resolved_name].copy()\n    # Késés napokban (kanonikus)\n    df_f[\"delay_days\"] = kesedelmes_napok(\n        df_f[\"due_in_date\"],\n        df_f[\"clear_date\"]\n    )\n    # Szűrés: késés + nagy összeg\n    df_filtered = df_f[\n        (df_f[\"delay_days\"] > MIN_DELAY_DAYS) &\n        (df_f[\"Brutto\"] > MIN_BRUTTO)\n    ].copy()\n    # Kimeneti táblázat\n    result = df_filtered[\n        [\n            \"invoice_nr\",\n            \"posting_date\",\n            \"due_in_date\",\n            \"clear_date\",\n            \"Brutto\",\n            \"delay_days\"\n        ]\n    ].reset_index(drop=True)"}
{"timestamp": "2026-02-18T17:05:23.384587", "event": "question_run", "previous_question": null, "user_input": "Válogasd le Danube Digital 654 Corp cég azon számláit egy táblázatba, amelyek 10 napon túl lettek fizetve és a bruttó számla összege nagyobb volt 1.500.000 Ft-nál!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Válogasd le Danube Digital 654 Corp cég azon számláit egy táblázatba, amelyek 10 napon túl lettek fizetve és a bruttó számla összege nagyobb volt 1.500.000 Ft-nál!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Paraméterek\nQUERY_NAME = \"Danube Digital 654 Corp\"\nMIN_DELAY_DAYS = 10\nMIN_BRUTTO = 1_500_000\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető vevő, dátum, összeg\ndf_tmp = df_tmp[\n    df_tmp[\"customer_name\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\n# Entitásfeloldás (KÖTELEZŐ)\ncandidates = sorted(df_tmp[\"customer_name\"].dropna().unique().tolist())\nresolved_name = resolve_entity(QUERY_NAME, candidates)\n\nif resolved_name is None:\n    result = {\n        \"message\": \"Nem található a megadott névhez illeszkedő ügyfél.\",\n        \"keresett_nev\": QUERY_NAME,\n        \"hasonlo_nevek\": candidates[:10]\n    }\nelse:\n    df_f = df_tmp[df_tmp[\"customer_name\"] == resolved_name].copy()\n    # Késés napokban\n    df_f[\"delay_days\"] = kesedelmes_napok(\n        df_f[\"due_in_date\"],\n        df_f[\"clear_date\"]\n    )\n    # Szűrés: késés + nagy összeg\n    df_filtered = df_f[\n        (df_f[\"delay_days\"] > MIN_DELAY_DAYS) &\n        (df_f[\"Brutto\"] > MIN_BRUTTO)\n    ].copy()\n    # Kimeneti táblázat\n    result = df_filtered[\n        [\n            \"invoice_nr\",\n            \"customer_name\",\n            \"posting_date\",\n            \"due_in_date\",\n            \"clear_date\",\n            \"Brutto\",\n            \"delay_days\"\n        ]\n    ].reset_index(drop=True)"}
{"timestamp": "2026-02-18T17:23:26.323305", "event": "question_run", "previous_question": null, "user_input": "Melyik cégben volt több késedelmes száma: 2024-ben vagy 2025-ben? ", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Melyik cégben volt több késedelmes száma: 2024-ben vagy 2025-ben? ", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nimport pandas as pd\n\n# Paraméterek\nYEARS = [2024, 2025]\nMIN_DELAY_DAYS = 1  # késedelmes = legalább 1 nap\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető sorok\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna() &\n    df_tmp[\"company\"].notna()\n].copy()\n\n# Év képzése\ndf_tmp[\"Year\"] = df_tmp[\"posting_date\"].dt.year\n\n# Csak 2024 és 2025\ndf_tmp = df_tmp[df_tmp[\"Year\"].isin(YEARS)].copy()\n\n# Késés napokban\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Késedelmes flag\ndf_tmp[\"kesedelmes\"] = df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n\n# Cég-év szintű késedelmes számlák száma\nstats = (\n    df_tmp\n    .groupby([\"company\", \"Year\"])[\"kesedelmes\"]\n    .sum()\n    .unstack(fill_value=0)\n)\n\n# Melyik cégben volt több késedelmes számla, melyik évben\nresult = {}\nfor company in stats.index:\n    n_2024 = int(stats.loc[company, 2024]) if 2024 in stats.columns else 0\n    n_2025 = int(stats.loc[company, 2025]) if 2025 in stats.columns else 0\n    if n_2024 > n_2025:\n        ev = 2024\n    elif n_2025 > n_2024:\n        ev = 2025\n    else:\n        ev = \"azonos\"\n    result[str(company)] = {\n        \"2024_kesedelmes_db\": n_2024,\n        \"2025_kesedelmes_db\": n_2025,\n        \"tobb_kesedelmes_ev\": ev\n    }"}
{"timestamp": "2026-02-18T17:34:15.107995", "event": "question_run", "previous_question": null, "user_input": "Melyik évben volt legtöbb késve fizetett számla? ", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Melyik évben volt legtöbb késve fizetett számla? ", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nimport pandas as pd\n\n# Paraméter\nMIN_DELAY_DAYS = 1  # késedelmes = legalább 1 nap\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető, kifizetett számlák\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna()\n].copy()\n\n# Késés napokban\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Késedelmes flag\ndf_tmp[\"kesedelmes\"] = df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Évenkénti késedelmes számlák száma\nkesedelmes_ev = (\n    df_tmp[df_tmp[\"kesedelmes\"]]\n    .groupby(\"Ev\")\n    .size()\n)\n\nif len(kesedelmes_ev) == 0:\n    result = None\nelse:\n    max_ev = int(kesedelmes_ev.idxmax())\n    result = max_ev"}
{"timestamp": "2026-02-18T17:34:57.591199", "event": "question_run", "previous_question": "Melyik évben volt legtöbb késve fizetett számla? ", "user_input": "Rajzold egy oszlop diagramot, ami minden évre mutatja hány késve fizetett számla volt az adott évben!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Rajzold egy oszlop diagramot, ami minden évre mutatja hány késve fizetett számla volt az adott évben!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nMIN_DELAY_DAYS = 1  # késedelmes = legalább 1 nap\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátumok\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna()\n].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Késés napokban\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Késedelmes flag\ndf_tmp[\"kesedelmes\"] = df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n\n# Évenkénti késedelmes számlák száma\nstats = (\n    df_tmp\n    .groupby(\"Ev\")[\"kesedelmes\"]\n    .sum()\n    .astype(int)\n    .reset_index(name=\"Keses_szamlak_szama\")\n)\n\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(stats[\"Ev\"].astype(str), stats[\"Keses_szamlak_szama\"])\n\nax.set_title(\"Késve fizetett számlák száma évente\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Késve fizetett számlák száma\")\n\nresult = fig"}
{"timestamp": "2026-02-18T17:36:33.383082", "event": "question_run", "previous_question": "Rajzold egy oszlop diagramot, ami minden évre mutatja hány késve fizetett számla volt az adott évben!", "user_input": "Mutasd egy táblázatban azt a 3 legnagyobb bruttó értékű számlát, amelyeknél több mint 30 napos fizetési késedelem volt! ", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Mutasd egy táblázatban azt a 3 legnagyobb bruttó értékű számlát, amelyeknél több mint 30 napos fizetési késedelem volt! ", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Paraméterek\nMIN_DELAY_DAYS = 31\nTOP_N = 3\n\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető, kifizetett számlák\ndf_tmp = df_tmp[\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna() &\n    df_tmp[\"Brutto\"].notna() &\n    df_tmp[\"customer_name\"].notna()\n].copy()\n\n# Késedelem napokban (kanonikus)\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Szűrés: több mint 30 napos késedelem\ndf_filtered = df_tmp[\n    df_tmp[\"delay_days\"] > MIN_DELAY_DAYS\n].copy()\n\n# TOP 3 legnagyobb bruttó értékű számla\ndf_top = (\n    df_filtered\n    .nlargest(TOP_N, \"Brutto\")\n    .loc[:, [\"invoice_nr\", \"customer_name\", \"Brutto\", \"delay_days\"]]\n    .reset_index(drop=True)\n)\n\nresult = df_top"}
{"timestamp": "2026-02-18T17:40:14.786751", "event": "question_run", "previous_question": "Mutasd egy táblázatban azt a 3 legnagyobb bruttó értékű számlát, amelyeknél több mint 30 napos fizetési késedelem volt! ", "user_input": "Mutass egy oszlop diagramot, ami éves bontásban mutatja hogy az adott évben mekkora volt egy átlagos bruttó számla érték! ", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Mutass egy oszlop diagramot, ami éves bontásban mutatja hogy az adott évben mekkora volt egy átlagos bruttó számla érték! ", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátum és összeg mezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves átlag bruttó összeg\nstats = (\n    df_tmp\n    .groupby(\"Ev\")[\"Brutto\"]\n    .mean()\n    .reset_index()\n)\n\n# Oszlopdiagram\nfrom matplotlib.ticker import FuncFormatter\n\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(stats[\"Ev\"].astype(str), stats[\"Brutto\"])\n\nax.set_title(\"Éves átlagos bruttó számlaérték\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Átlagos bruttó számlaérték (Ft)\")\n\nax.yaxis.set_major_formatter(\n    FuncFormatter(lambda x, _: f\"{int(round(x)):,}\".replace(\",\", \" \"))\n)\n\nresult = fig"}
{"timestamp": "2026-02-18T17:50:51.837290", "event": "question_run", "previous_question": null, "user_input": "Mutasd egy táblázatban azt a 3 legnagyobb bruttó értékű számlát, amelyeknél több mint 30 napos fizetési késedelem volt!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Mutasd egy táblázatban azt a 3 legnagyobb bruttó értékű számlát, amelyeknél több mint 30 napos fizetési késedelem volt!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Paraméterek\nMIN_DELAY_DAYS = 31  # több mint 30 napos késedelem\nTOP_N = 3\n\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető, kifizetett számlák\ndf_tmp = df_tmp[\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna() &\n    df_tmp[\"Brutto\"].notna() &\n    df_tmp[\"customer_name\"].notna()\n].copy()\n\n# Késedelem napokban (kanonikus)\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Szűrés: több mint 30 napos késedelem\ndf_filtered = df_tmp[\n    df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n].copy()\n\n# 3 legnagyobb bruttó értékű számla\ndf_top = (\n    df_filtered\n    .nlargest(TOP_N, \"Brutto\")\n    .loc[:, [\"invoice_nr\", \"customer_name\", \"Brutto\", \"delay_days\"]]\n    .reset_index(drop=True)\n)\n\nresult = df_top"}
{"timestamp": "2026-02-18T17:51:11.982657", "event": "question_run", "previous_question": "Mutasd egy táblázatban azt a 3 legnagyobb bruttó értékű számlát, amelyeknél több mint 30 napos fizetési késedelem volt!", "user_input": "Melyik évben volt legtöbb késve fizetett számla?", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Melyik évben volt legtöbb késve fizetett számla?", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nimport pandas as pd\n\n# Paraméter\nMIN_DELAY_DAYS = 1  # késedelmes = legalább 1 nap csúszás\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátumok\ndf_tmp = df_tmp[\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna()\n].copy()\n\n# Késés napokban (kanonikus)\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Késedelmes flag\ndf_tmp[\"kesedelmes\"] = df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n\n# Év képzése (kiállítás dátuma alapján)\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Késedelmes számlák száma évenként\nkesedelmes_ev = (\n    df_tmp[df_tmp[\"kesedelmes\"]]\n    .groupby(\"Ev\")\n    .size()\n)\n\nif len(kesedelmes_ev) == 0:\n    result = None\nelse:\n    max_ev = int(kesedelmes_ev.idxmax())\n    result = max_ev"}
{"timestamp": "2026-02-18T17:51:38.258024", "event": "question_run", "previous_question": "Melyik évben volt legtöbb késve fizetett számla?", "user_input": "Mutass egy oszlop diagramot, ami éves bontásban mutatja hogy az adott évben mekkora volt egy átlagos bruttó számla érték!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Mutass egy oszlop diagramot, ami éves bontásban mutatja hogy az adott évben mekkora volt egy átlagos bruttó számla érték!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nimport pandas as pd\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummező biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátum és bruttó összeg\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves átlag bruttó összeg\nstats = (\n    df_tmp\n    .groupby(\"Ev\")[\"Brutto\"]\n    .mean()\n    .reset_index()\n)\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(stats[\"Ev\"].astype(str), stats[\"Brutto\"])\n\nax.set_title(\"Éves átlagos bruttó számlaérték\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Átlagos bruttó számlaérték (Ft)\")\n\n# Ezres tagolás a y tengelyen\nax.yaxis.set_major_formatter(\n    FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \"))\n)\n\nresult = fig"}
{"timestamp": "2026-02-18T18:02:04.256782", "event": "question_run", "previous_question": null, "user_input": "Melyik évben volt legtöbb késve fizetett számla?", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Melyik évben volt legtöbb késve fizetett számla?", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nimport pandas as pd\n\n# Paraméter\nMIN_DELAY_DAYS = 1  # késedelmes = legalább 1 nap\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátumok\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna()\n].copy()\n\n# Késés napokban\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Késedelmes flag\ndf_tmp[\"kesedelmes\"] = df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Késedelmes számlák száma évenként\nstats = (\n    df_tmp[df_tmp[\"kesedelmes\"]]\n    .groupby(\"Ev\")\n    .size()\n)\n\nif len(stats) == 0:\n    result = None\nelse:\n    max_year = int(stats.idxmax())\n    result = max_year"}
{"timestamp": "2026-02-18T18:05:10.540571", "event": "question_run", "previous_question": null, "user_input": "Rajzold egy oszlop diagramot, ami minden évre mutatja hány késve fizetett számla volt az adott évben!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Rajzold egy oszlop diagramot, ami minden évre mutatja hány késve fizetett számla volt az adott évben!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Paraméter\nMIN_DELAY_DAYS = 1  # késedelmes = legalább 1 nap csúszás\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető kiállítási dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Csak ahol van határidő és kifizetési dátum\ndf_paid = df_tmp[\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna()\n].copy()\n\n# Késés napokban\ndf_paid[\"delay_days\"] = kesedelmes_napok(\n    df_paid[\"due_in_date\"],\n    df_paid[\"clear_date\"]\n)\n\n# Késedelmes flag\ndf_paid[\"kesedelmes\"] = df_paid[\"delay_days\"] >= MIN_DELAY_DAYS\n\n# Évenkénti késedelmes számlák száma\nstats = (\n    df_paid\n    .groupby(\"Ev\")[\"kesedelmes\"]\n    .sum()\n    .astype(int)\n    .reset_index(name=\"Kesedelmes_szamlak_szama\")\n)\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(\n    stats[\"Ev\"].astype(str),\n    stats[\"Kesedelmes_szamlak_szama\"]\n)\n\nax.set_title(\"Késve fizetett számlák száma évente\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Késve fizetett számlák száma\")\n\nresult = fig"}
{"timestamp": "2026-02-18T18:10:59.947318", "event": "question_run", "previous_question": null, "user_input": "Mutass egy oszlop diagramot, ami éves bontásban mutatja hogy az adott évben mekkora volt egy átlagos bruttó számla érték!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Mutass egy oszlop diagramot, ami éves bontásban mutatja hogy az adott évben mekkora volt egy átlagos bruttó számla érték!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom matplotlib.ticker import FuncFormatter\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátum és bruttó mezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves átlag bruttó érték\nstats = (\n    df_tmp\n    .groupby(\"Ev\")[\"Brutto\"]\n    .mean()\n    .reset_index(name=\"Atlag_Brutto\")\n)\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(stats[\"Ev\"].astype(str), stats[\"Atlag_Brutto\"])\n\nax.set_title(\"Éves átlagos bruttó számlaérték\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Átlagos bruttó érték (Ft)\")\n\nax.yaxis.set_major_formatter(\n    FuncFormatter(lambda x, _: f\"{int(round(x)):,}\".replace(\",\", \" \"))\n)\n\nresult = fig"}
{"timestamp": "2026-02-18T18:13:46.862862", "event": "question_run", "previous_question": null, "user_input": "Mutass egy oszlop diagramot, ami éves bontásban mutatja hogy az adott évben mekkora volt egy átlagos bruttó számla érték!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Mutass egy oszlop diagramot, ami éves bontásban mutatja hogy az adott évben mekkora volt egy átlagos bruttó számla érték!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nimport pandas as pd\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummező biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátum és bruttó összeg\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves átlag bruttó összeg\nstats = (\n    df_tmp\n    .groupby(\"Ev\")[\"Brutto\"]\n    .mean()\n    .reset_index()\n)\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(stats[\"Ev\"].astype(str), stats[\"Brutto\"])\n\nax.set_title(\"Éves átlagos bruttó számlaérték\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Átlagos bruttó számlaérték (Ft)\")\n\n# Ezres tagolás a y tengelyen\nax.yaxis.set_major_formatter(\n    FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \"))\n)\n\nresult = fig"}
{"timestamp": "2026-02-18T18:17:55.779135", "event": "question_run", "previous_question": null, "user_input": "Mutass egy oszlop diagramot, ami éves bontásban mutatja hogy az adott évben mekkora volt egy átlagos bruttó számla érték!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Mutass egy oszlop diagramot, ami éves bontásban mutatja hogy az adott évben mekkora volt egy átlagos bruttó számla érték!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom matplotlib.ticker import FuncFormatter\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátum és összeg mezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves átlag bruttó összeg\nstats = (\n    df_tmp\n    .groupby(\"Ev\")[\"Brutto\"]\n    .mean()\n    .reset_index()\n)\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(stats[\"Ev\"].astype(str), stats[\"Brutto\"])\n\nax.set_title(\"Éves átlagos bruttó számlaérték\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Átlagos bruttó számlaérték (Ft)\")\n\nax.yaxis.set_major_formatter(\n    FuncFormatter(lambda x, _: f\"{int(round(x)):,}\".replace(\",\", \" \"))\n)\n\nresult = fig"}
{"timestamp": "2026-02-18T18:31:48.669207", "event": "question_run", "previous_question": null, "user_input": "Melyik évben volt legtöbb számla kiállítva? ", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Melyik évben volt legtöbb számla kiállítva? ", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndf_tmp = df.copy()\n\n# Kiállítás dátumának biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(\n    df_tmp[\"posting_date\"], errors=\"coerce\"\n)\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Számlák darabszáma évenként\ncounts = df_tmp.groupby(\"Ev\").size()\n\nif len(counts) == 0:\n    result = None\nelse:\n    max_year = int(counts.idxmax())\n    result = max_year"}
{"timestamp": "2026-02-18T18:32:11.143698", "event": "question_run", "previous_question": "Melyik évben volt legtöbb számla kiállítva? ", "user_input": "Hány darab számla volt kiállítva 2027-ben? ", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Hány darab számla volt kiállítva 2027-ben? ", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nYEAR = 2027\n\ndf_tmp = df.copy()\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_filtered = df_tmp[df_tmp[\"posting_date\"].dt.year == YEAR]\nresult = int(len(df_filtered))"}
{"timestamp": "2026-02-18T18:32:44.194952", "event": "question_run", "previous_question": "Hány darab számla volt kiállítva 2027-ben? ", "user_input": "Hány darab számla volt kiállítva 2027-ben? ", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Hány darab számla volt kiállítva 2027-ben? ", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nYEAR = 2027\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(\n    df_tmp[\"posting_date\"], errors=\"coerce\"\n)\n\ndf_filtered = df_tmp[\n    df_tmp[\"posting_date\"].dt.year == YEAR\n]\n\nresult = int(len(df_filtered))"}
{"timestamp": "2026-02-18T18:33:03.927472", "event": "question_run", "previous_question": "Hány darab számla volt kiállítva 2027-ben? ", "user_input": "Melyik évben volt legtöbb számla kiállítva?", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Melyik évben volt legtöbb számla kiállítva?", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndf_tmp = df.copy()\n\n# Kiállítás dátumának biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(\n    df_tmp[\"posting_date\"], errors=\"coerce\"\n)\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Számlák darabszáma évenként\ncounts = df_tmp.groupby(\"Ev\").size()\n\nif len(counts) == 0:\n    result = None\nelse:\n    max_year = int(counts.idxmax())\n    max_count = int(counts.max())\n    result = {\n        \"ev\": max_year,\n        \"szamlak_szama\": max_count\n    }"}
{"timestamp": "2026-02-18T18:33:18.515350", "event": "question_run", "previous_question": "Melyik évben volt legtöbb számla kiállítva?", "user_input": "Hány darab számla volt kiállítva 2017-ben?", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Hány darab számla volt kiállítva 2017-ben?", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nYEAR = 2017\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(\n    df_tmp[\"posting_date\"], errors=\"coerce\"\n)\n\ndf_2017 = df_tmp[\n    df_tmp[\"posting_date\"].dt.year == YEAR\n]\n\nresult = int(len(df_2017))"}
{"timestamp": "2026-02-18T18:34:41.076488", "event": "question_run", "previous_question": "Hány darab számla volt kiállítva 2017-ben?", "user_input": "Hány számla volt 2022-ben kiállítva? ", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Hány számla volt 2022-ben kiállítva? ", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nYEAR = 2022\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(\n    df_tmp[\"posting_date\"], errors=\"coerce\"\n)\n\ndf_filtered = df_tmp[\n    df_tmp[\"posting_date\"].dt.year == YEAR\n]\n\nresult = int(len(df_filtered))"}
{"timestamp": "2026-02-18T18:35:05.040202", "event": "question_run", "previous_question": "Hány számla volt 2022-ben kiállítva? ", "user_input": "Melyik évben volt legtöbb késve fizetett számla?", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Melyik évben volt legtöbb késve fizetett számla?", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nimport pandas as pd\n\n# Paraméter\nMIN_DELAY_DAYS = 1  # késedelmes = legalább 1 nap\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető, kifizetett számlák\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna()\n].copy()\n\n# Késés napokban\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Késedelmes flag\ndf_tmp[\"kesedelmes\"] = df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Évenkénti késedelmes számlák száma\nkesedelmes_ev = (\n    df_tmp[df_tmp[\"kesedelmes\"]]\n    .groupby(\"Ev\")\n    .size()\n)\n\nif len(kesedelmes_ev) == 0:\n    result = None\nelse:\n    max_ev = kesedelmes_ev.idxmax()\n    result = int(max_ev)"}
{"timestamp": "2026-02-18T18:35:30.508100", "event": "question_run", "previous_question": "Melyik évben volt legtöbb késve fizetett számla?", "user_input": "Mutass egy oszlop diagramot, ami éves bontásban mutatja hogy az adott évben mekkora volt egy átlagos bruttó számla érték!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Mutass egy oszlop diagramot, ami éves bontásban mutatja hogy az adott évben mekkora volt egy átlagos bruttó számla érték!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nimport pandas as pd\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátum és összeg mezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves átlag bruttó összeg\nstats = (\n    df_tmp\n    .groupby(\"Ev\")[\"Brutto\"]\n    .mean()\n    .reset_index()\n)\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(stats[\"Ev\"].astype(str), stats[\"Brutto\"])\n\nax.set_title(\"Éves átlagos bruttó számlaérték\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Átlagos bruttó számla (Ft)\")\n\n# Ezres tagolás a y tengelyen\nax.yaxis.set_major_formatter(\n    FuncFormatter(lambda x, _: f\"{int(round(x)):,}\".replace(\",\", \" \"))\n)\n\nresult = fig"}
{"timestamp": "2026-02-18T18:37:08.503016", "event": "question_run", "previous_question": "Mutass egy oszlop diagramot, ami éves bontásban mutatja hogy az adott évben mekkora volt egy átlagos bruttó számla érték!", "user_input": "Mutass egy oszlop diagramot, ami 2023-as számlákra havi szinten mutatja az átlagos bruttó számlaértéket\n", "gate_decision": "FOLLOWUP", "rewritten_question": "Mutass egy oszlopdiagramot, amely a 2023-as számlák esetén havi bontásban ábrázolja az átlagos bruttó számlaértéket!", "final_question": "Mutass egy oszlopdiagramot, amely a 2023-as számlák esetén havi bontásban ábrázolja az átlagos bruttó számlaértéket!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom matplotlib.ticker import FuncFormatter\n\nYEAR = 2023\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\ndf_tmp = df_tmp[\n    (df_tmp[\"posting_date\"].notna()) &\n    (df_tmp[\"posting_date\"].dt.year == YEAR) &\n    (df_tmp[\"Brutto\"].notna())\n].copy()\n\ndf_tmp[\"Honap\"] = df_tmp[\"posting_date\"].dt.to_period(\"M\").dt.to_timestamp()\n\nmonthly_avg = (\n    df_tmp\n    .groupby(\"Honap\")[\"Brutto\"]\n    .mean()\n    .reset_index()\n)\n\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(monthly_avg[\"Honap\"], monthly_avg[\"Brutto\"], width=20)\n\nax.set_title(\"Átlagos bruttó számlaérték 2023-ban – havi bontásban\")\nax.set_xlabel(\"Hónap\")\nax.set_ylabel(\"Átlagos bruttó számlaérték (Ft)\")\n\nax.yaxis.set_major_formatter(\n    FuncFormatter(lambda x, _: f\"{int(round(x)):,}\".replace(\",\", \" \"))\n)\n\nresult = fig"}
{"timestamp": "2026-02-18T18:37:36.969901", "event": "question_run", "previous_question": "Mutass egy oszlopdiagramot, amely a 2023-as számlák esetén havi bontásban ábrázolja az átlagos bruttó számlaértéket!", "user_input": "Melyik ügyfélnek volt 2025-ben legtöbb késve fizetett számlája?", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Melyik ügyfélnek volt 2025-ben legtöbb késve fizetett számlája?", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nimport pandas as pd\n\nYEAR = 2025\nMIN_DELAY_DAYS = 1\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak 2025-ös, értelmezhető ügyfél, határidő és kifizetési dátum\ndf_tmp = df_tmp[\n    (df_tmp[\"posting_date\"].dt.year == YEAR) &\n    df_tmp[\"customer_name\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna()\n].copy()\n\n# Késés napokban\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Késedelmes flag\ndf_tmp[\"kesedelmes\"] = df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n\n# Csak késedelmesek\ndf_delayed = df_tmp[df_tmp[\"kesedelmes\"]].copy()\n\nif len(df_delayed) == 0:\n    result = None\nelse:\n    counts = (\n        df_delayed\n        .groupby(\"customer_name\")\n        .size()\n        .sort_values(ascending=False)\n    )\n    top_customer = str(counts.index[0])\n    top_count = int(counts.iloc[0])\n    result = {\n        \"ugyfel\": top_customer,\n        \"kesedelmes_szamlak_szama\": top_count\n    }"}
{"timestamp": "2026-02-18T18:38:07.595440", "event": "question_run", "previous_question": "Melyik ügyfélnek volt 2025-ben legtöbb késve fizetett számlája?", "user_input": "Melyik évben volt legtöbb késve fizetett számla?", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Melyik évben volt legtöbb késve fizetett számla?", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nimport pandas as pd\n\n# Paraméter\nMIN_DELAY_DAYS = 1  # késedelmes = legalább 1 nap\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátumok\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna()\n].copy()\n\n# Késés napokban (kanonikus)\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Késedelmes flag\ndf_tmp[\"kesedelmes\"] = df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Évenkénti késedelmes számlák száma\nkesedelmes_ev = (\n    df_tmp[df_tmp[\"kesedelmes\"]]\n    .groupby(\"Ev\")\n    .size()\n)\n\nif len(kesedelmes_ev) == 0:\n    result = None\nelse:\n    max_ev = int(kesedelmes_ev.idxmax())\n    result = max_ev"}
{"timestamp": "2026-02-18T18:38:27.176177", "event": "question_run", "previous_question": "Melyik évben volt legtöbb késve fizetett számla?", "user_input": "Melyik évben volt a legkevesebb számla?\n", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Melyik évben volt a legkevesebb számla?\n", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\ndf_tmp[\"ev\"] = df_tmp[\"posting_date\"].dt.year\n\ncounts = df_tmp.groupby(\"ev\").size()\n\nif len(counts) == 0:\n    result = None\nelse:\n    min_year = int(counts.idxmin())\n    min_count = int(counts.min())\n    result = {\"ev\": min_year, \"szamlak_szama\": min_count}"}
{"timestamp": "2026-02-18T18:45:35.174837", "event": "question_run", "previous_question": null, "user_input": "Rajzold egy oszlop diagramot, ami minden évre mutatja hány késve fizetett számla volt az adott évben!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Rajzold egy oszlop diagramot, ami minden évre mutatja hány késve fizetett számla volt az adott évben!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nMIN_DELAY_DAYS = 1\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátumok\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna()\n].copy()\n\n# Késedelmes napok számítása (kanonikus)\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Késedelmes flag\ndf_tmp[\"kesedelmes\"] = df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Évenkénti késedelmes számlák száma\nstats = (\n    df_tmp\n    .groupby(\"Ev\")[\"kesedelmes\"]\n    .sum()\n    .astype(int)\n    .reset_index(name=\"Kesedelmes_szamlak_szama\")\n)\n\n# Diagram\nfig, ax = plt.subplots(figsize=(8,3))\nbars = ax.bar(\n    stats[\"Ev\"].astype(str),\n    stats[\"Kesedelmes_szamlak_szama\"]\n)\n\nax.set_title(\"Késve fizetett számlák száma évente\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Késve fizetett számlák száma\")\n\nfrom matplotlib.ticker import FuncFormatter\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \")))\n\nresult = fig"}
{"timestamp": "2026-02-18T18:47:42.388122", "event": "question_run", "previous_question": null, "user_input": "Rajzold egy oszlop diagramot, ami minden évre mutatja hány késve fizetett számla volt az adott évben!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Rajzold egy oszlop diagramot, ami minden évre mutatja hány késve fizetett számla volt az adott évben!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Paraméter\nMIN_DELAY_DAYS = 1  # késedelmes = legalább 1 nap csúszás\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető kiállítási dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Késés napokban (csak ahol van határidő és kifizetés)\nmask = df_tmp[\"due_in_date\"].notna() & df_tmp[\"clear_date\"].notna()\ndf_tmp.loc[mask, \"delay_days\"] = kesedelmes_napok(\n    df_tmp.loc[mask, \"due_in_date\"],\n    df_tmp.loc[mask, \"clear_date\"]\n)\n\n# Késedelmes flag\ndf_tmp[\"kesedelmes\"] = False\ndf_tmp.loc[mask, \"kesedelmes\"] = df_tmp.loc[mask, \"delay_days\"] >= MIN_DELAY_DAYS\n\n# Évenkénti késedelmes számlák száma\nstats = (\n    df_tmp\n    .groupby(\"Ev\")[\"kesedelmes\"]\n    .sum()\n    .astype(int)\n    .reset_index(name=\"Kesedelmes_szamlak_szama\")\n)\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nbars = ax.bar(\n    stats[\"Ev\"].astype(str),\n    stats[\"Kesedelmes_szamlak_szama\"]\n)\n\nax.set_title(\"Késve fizetett számlák száma évente\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Késve fizetett számlák száma\")\n\nfrom matplotlib.ticker import FuncFormatter\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \")))\n\nresult = fig"}
{"timestamp": "2026-02-18T18:48:23.094057", "event": "question_run", "previous_question": "Rajzold egy oszlop diagramot, ami minden évre mutatja hány késve fizetett számla volt az adott évben!", "user_input": "Ne legyen benne rácsvonal! ", "gate_decision": "FOLLOWUP", "rewritten_question": "Rajzolj egy oszlopdiagramot, amely minden évre mutatja, hány késve fizetett számla volt az adott évben, de ne legyen benne rácsvonal!", "final_question": "Rajzolj egy oszlopdiagramot, amely minden évre mutatja, hány késve fizetett számla volt az adott évben, de ne legyen benne rácsvonal!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nMIN_DELAY_DAYS = 1\n\ndf_tmp = df.copy()\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátumok\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna()\n].copy()\n\n# Késés napokban\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Késve fizetett flag\ndf_tmp[\"kesedelmes\"] = df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Aggregáció: késve fizetett számlák száma évente\nstats = (\n    df_tmp[df_tmp[\"kesedelmes\"]]\n    .groupby(\"Ev\")\n    .size()\n    .reset_index(name=\"Keses_szamlak_szama\")\n)\n\n# Diagram\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(stats[\"Ev\"].astype(str), stats[\"Keses_szamlak_szama\"])\n\nax.set_title(\"Késve fizetett számlák száma évente\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Késve fizetett számlák száma\")\nax.grid(False)\n\nresult = fig"}
{"timestamp": "2026-02-18T18:49:23.935438", "event": "question_run", "previous_question": null, "user_input": "Mutass egy oszlop diagramot, ami éves bontásban mutatja hogy az adott évben mekkora volt egy átlagos bruttó számla érték!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Mutass egy oszlop diagramot, ami éves bontásban mutatja hogy az adott évben mekkora volt egy átlagos bruttó számla érték!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom matplotlib.ticker import FuncFormatter\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummező biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátum és bruttó összeg\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves átlag bruttó összeg\nstats = (\n    df_tmp\n    .groupby(\"Ev\")[\"Brutto\"]\n    .mean()\n    .reset_index()\n)\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(stats[\"Ev\"].astype(str), stats[\"Brutto\"])\n\nax.set_title(\"Éves átlagos bruttó számlaérték\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Átlagos bruttó számlaérték (Ft)\")\n\n# Ezres tagolás a y tengelyen\nax.yaxis.set_major_formatter(\n    FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \"))\n)\n\nresult = fig"}
{"timestamp": "2026-02-18T18:49:51.734165", "event": "question_run", "previous_question": "Mutass egy oszlop diagramot, ami éves bontásban mutatja hogy az adott évben mekkora volt egy átlagos bruttó számla érték!", "user_input": "Ne legyen benne rácsvonal! ", "gate_decision": "FOLLOWUP", "rewritten_question": "Készíts egy oszlopdiagramot, amely éves bontásban mutatja az adott év átlagos bruttó számlaértékét, rácsvonalak nélkül!", "final_question": "Készíts egy oszlopdiagramot, amely éves bontásban mutatja az adott év átlagos bruttó számlaértékét, rácsvonalak nélkül!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummező biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátum és bruttó összeg\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves átlagos bruttó számlaérték\nstats = (\n    df_tmp\n    .groupby(\"Ev\")[\"Brutto\"]\n    .mean()\n    .reset_index()\n)\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nbars = ax.bar(\n    stats[\"Ev\"].astype(str),\n    stats[\"Brutto\"],\n    color=\"#4477AA\"\n)\n\nax.set_title(\"Éves átlagos bruttó számlaérték\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Átlagos bruttó számlaérték (Ft)\")\n\n# Ezres tagolás a tengelyen\nfrom matplotlib.ticker import FuncFormatter\nax.yaxis.set_major_formatter(\n    FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \"))\n)\n\n# Rácsvonalak eltávolítása\nax.grid(False)\n\nresult = fig"}
{"timestamp": "2026-02-18T18:52:37.312628", "event": "question_run", "previous_question": null, "user_input": "Mutass egy oszlopdiagramot, amely a 2023-as számlák esetén havi bontásban ábrázolja az átlagos bruttó számlaértéket!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Mutass egy oszlopdiagramot, amely a 2023-as számlák esetén havi bontásban ábrázolja az átlagos bruttó számlaértéket!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom matplotlib.ticker import FuncFormatter\n\nYEAR = 2023\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\ndf_2023 = df_tmp[\n    df_tmp[\"posting_date\"].dt.year == YEAR\n].copy()\n\ndf_2023[\"Honap\"] = df_2023[\"posting_date\"].dt.to_period(\"M\").dt.to_timestamp()\n\nmonthly_avg = (\n    df_2023\n    .groupby(\"Honap\")[\"Brutto\"]\n    .mean()\n    .reset_index(name=\"Atlag_Brutto\")\n)\n\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(monthly_avg[\"Honap\"], monthly_avg[\"Atlag_Brutto\"], width=20)\n\nax.set_title(\"Átlagos bruttó számlaérték 2023-ban – havi bontásban\")\nax.set_xlabel(\"Hónap\")\nax.set_ylabel(\"Átlagos bruttó számlaérték (Ft)\")\n\nax.yaxis.set_major_formatter(\n    FuncFormatter(lambda x, _: f\"{int(round(x)):,}\".replace(\",\", \" \"))\n)\n\nresult = fig"}
{"timestamp": "2026-02-18T18:54:42.937985", "event": "question_run", "previous_question": "Mutass egy oszlopdiagramot, amely a 2023-as számlák esetén havi bontásban ábrázolja az átlagos bruttó számlaértéket!", "user_input": "Ne legyen benne rácsvonal! ", "gate_decision": "FOLLOWUP", "rewritten_question": "Készíts egy oszlopdiagramot, amely a 2023-as számlák esetén havi bontásban ábrázolja az átlagos bruttó számlaértéket, rácsvonalak nélkül!", "final_question": "Készíts egy oszlopdiagramot, amely a 2023-as számlák esetén havi bontásban ábrázolja az átlagos bruttó számlaértéket, rácsvonalak nélkül!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nYEAR = 2023\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\ndf_tmp = df_tmp[\n    (df_tmp[\"posting_date\"].notna()) &\n    (df_tmp[\"posting_date\"].dt.year == YEAR) &\n    (df_tmp[\"Brutto\"].notna())\n].copy()\n\ndf_tmp[\"Honap\"] = df_tmp[\"posting_date\"].dt.to_period(\"M\").dt.to_timestamp()\n\nmonthly_avg = (\n    df_tmp\n    .groupby(\"Honap\")[\"Brutto\"]\n    .mean()\n    .reset_index()\n)\n\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(monthly_avg[\"Honap\"], monthly_avg[\"Brutto\"], width=20)\n\nax.set_title(\"Átlagos bruttó számlaérték 2023-ban – havi bontás\")\nax.set_xlabel(\"Hónap\")\nax.set_ylabel(\"Átlagos bruttó számlaérték (Ft)\")\n\nax.grid(False)\n\nfrom matplotlib.ticker import FuncFormatter\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \")))\n\nresult = fig"}
{"timestamp": "2026-02-18T19:06:58.476235", "event": "question_run", "previous_question": null, "user_input": "Mutass egy oszlopdiagramot, amely a 2023-as számlák esetén havi bontásban ábrázolja az átlagos bruttó számlaértéket!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Mutass egy oszlopdiagramot, amely a 2023-as számlák esetén havi bontásban ábrázolja az átlagos bruttó számlaértéket!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom matplotlib.ticker import FuncFormatter\n\nYEAR = 2023\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\ndf_2023 = df_tmp[df_tmp[\"posting_date\"].dt.year == YEAR].copy()\n\ndf_2023[\"Honap\"] = df_2023[\"posting_date\"].dt.to_period(\"M\").dt.to_timestamp()\n\nmonthly_avg = (\n    df_2023\n    .groupby(\"Honap\")[\"Brutto\"]\n    .mean()\n    .reset_index(name=\"Atlag_Brutto\")\n)\n\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(monthly_avg[\"Honap\"], monthly_avg[\"Atlag_Brutto\"], width=20)\n\nax.set_title(\"Átlagos bruttó számlaérték 2023-ban – havi bontásban\")\nax.set_xlabel(\"Hónap\")\nax.set_ylabel(\"Átlagos bruttó számlaérték (Ft)\")\n\nax.yaxis.set_major_formatter(\n    FuncFormatter(lambda x, _: f\"{int(round(x)):,}\".replace(\",\", \" \"))\n)\n\nresult = fig"}
{"timestamp": "2026-02-18T19:07:23.397973", "event": "question_run", "previous_question": "Mutass egy oszlopdiagramot, amely a 2023-as számlák esetén havi bontásban ábrázolja az átlagos bruttó számlaértéket!", "user_input": "Ne legyen benne rácsvonal!", "gate_decision": "FOLLOWUP", "rewritten_question": "Készíts egy oszlopdiagramot, amely a 2023-as számlák esetén havi bontásban ábrázolja az átlagos bruttó számlaértéket, rácsvonalak nélkül!", "final_question": "Készíts egy oszlopdiagramot, amely a 2023-as számlák esetén havi bontásban ábrázolja az átlagos bruttó számlaértéket, rácsvonalak nélkül!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nYEAR = 2023\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    (df_tmp[\"posting_date\"].dt.year == YEAR) &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\ndf_tmp[\"Honap\"] = df_tmp[\"posting_date\"].dt.to_period(\"M\").dt.to_timestamp()\n\nmonthly_avg = (\n    df_tmp\n    .groupby(\"Honap\")[\"Brutto\"]\n    .mean()\n    .reset_index()\n)\n\nfig, ax = plt.subplots(figsize=(8,3))\nbars = ax.bar(\n    monthly_avg[\"Honap\"],\n    monthly_avg[\"Brutto\"],\n    width=20\n)\n\nax.set_title(\"Átlagos bruttó számlaérték – 2023, havi bontás\")\nax.set_xlabel(\"Hónap\")\nax.set_ylabel(\"Átlagos bruttó számlaérték (Ft)\")\n\nfrom matplotlib.ticker import FuncFormatter\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \")))\n\nax.grid(False)\n\nresult = fig"}
{"timestamp": "2026-02-18T19:08:32.757189", "event": "question_run", "previous_question": "Készíts egy oszlopdiagramot, amely a 2023-as számlák esetén havi bontásban ábrázolja az átlagos bruttó számlaértéket, rácsvonalak nélkül!", "user_input": "Készíts egy oszlop diagramot ami minden évre külön mutatja az időben fizetett és késve fizetett számlák átlagos bruttó értékét! ", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Készíts egy oszlop diagramot ami minden évre külön mutatja az időben fizetett és késve fizetett számlák átlagos bruttó értékét! ", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nimport pandas as pd\nimport numpy as np\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető, kifizetett számlák\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Késés napokban (kanonikus)\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Késve fizetett flag\ndf_tmp[\"kesve\"] = df_tmp[\"delay_days\"] >= 1\n\n# Csoportosítás: év + időben/késve\ndf_tmp[\"status\"] = np.where(df_tmp[\"kesve\"], \"Késve fizetett\", \"Időben fizetett\")\n\nagg = (\n    df_tmp\n    .groupby([\"Ev\", \"status\"])[\"Brutto\"]\n    .mean()\n    .unstack(fill_value=0)\n    .sort_index()\n)\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\n\nwidth = 0.35\nx = np.arange(len(agg.index))\n\nbar1 = ax.bar(x - width/2, agg.get(\"Időben fizetett\", pd.Series([0]*len(x))), width, label=\"Időben fizetett\")\nbar2 = ax.bar(x + width/2, agg.get(\"Késve fizetett\", pd.Series([0]*len(x))), width, label=\"Késve fizetett\")\n\nax.set_xticks(x)\nax.set_xticklabels(agg.index.astype(str))\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Átlagos bruttó érték (Ft)\")\nax.set_title(\"Átlagos bruttó érték – időben vs. késve fizetett számlák (évenként)\")\nax.legend()\n\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \")))\n\nresult = fig"}
{"timestamp": "2026-02-18T19:09:52.708656", "event": "question_run", "previous_question": "Készíts egy oszlop diagramot ami minden évre külön mutatja az időben fizetett és késve fizetett számlák átlagos bruttó értékét! ", "user_input": "Mutasd táblázatban azokat a 2023-as késve fizetett számlákat, amelyeknek a bruttó összege 3000000 Ft felett volt!", "gate_decision": "FOLLOWUP", "rewritten_question": "Mutasd táblázatban a 2023-as késve fizetett számlákat, amelyeknek a bruttó összege meghaladta a 3 000 000 Ft-ot!", "final_question": "Mutasd táblázatban a 2023-as késve fizetett számlákat, amelyeknek a bruttó összege meghaladta a 3 000 000 Ft-ot!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Paraméterek\nYEAR = 2023\nMIN_BRUTTO = 3_000_000\nMIN_DELAY_DAYS = 1  # késedelmes = legalább 1 nap\n\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető, kifizetett számlák\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\n# Csak 2023-as számlák\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].dt.year == YEAR\n].copy()\n\n# Késés napokban\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Késedelmes flag\ndf_tmp[\"kesedelmes\"] = df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n\n# Szűrés: késve fizetett, bruttó > 3M Ft\ndf_filtered = df_tmp[\n    (df_tmp[\"kesedelmes\"]) &\n    (df_tmp[\"Brutto\"] > MIN_BRUTTO)\n].copy()\n\n# Kimeneti táblázat\nresult = df_filtered[\n    [\n        \"invoice_nr\",\n        \"customer_name\",\n        \"posting_date\",\n        \"due_in_date\",\n        \"clear_date\",\n        \"Brutto\",\n        \"delay_days\"\n    ]\n].reset_index(drop=True)"}
{"timestamp": "2026-02-19T08:01:12.233185", "event": "question_run", "previous_question": null, "user_input": "Melyik évben volt a legkevesebb számla?", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Melyik évben volt a legkevesebb számla?", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\ndf_tmp[\"ev\"] = df_tmp[\"posting_date\"].dt.year\n\ncounts = df_tmp.groupby(\"ev\").size()\n\nif len(counts) == 0:\n    result = None\nelse:\n    min_year = int(counts.idxmin())\n    min_count = int(counts.min())\n    result = {\"ev\": min_year, \"szamlak_szama\": min_count}"}
{"timestamp": "2026-02-19T08:01:59.872438", "event": "question_run", "previous_question": "Melyik évben volt a legkevesebb számla?", "user_input": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummező biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves számlaszám aggregáció\ncounts = (\n    df_tmp\n    .groupby(\"Ev\")\n    .size()\n    .reset_index(name=\"Szamlak_szama\")\n)\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(counts[\"Ev\"].astype(str), counts[\"Szamlak_szama\"])\n\nax.set_title(\"Számlák száma évente\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Számlák száma\")\n\nresult = fig"}
{"timestamp": "2026-02-19T08:02:58.877618", "event": "question_run", "previous_question": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "user_input": "Melyik évben volt a legkevesebb számla?", "gate_decision": "FOLLOWUP", "rewritten_question": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, és emeld ki azt az évet, amikor a legkevesebb számla volt!", "final_question": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, és emeld ki azt az évet, amikor a legkevesebb számla volt!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummező biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves számlaszám\ncounts = (\n    df_tmp\n    .groupby(\"Ev\")\n    .size()\n    .reset_index(name=\"Szamlak_szama\")\n)\n\n# Legkevesebb számlás év\nmin_idx = counts[\"Szamlak_szama\"].idxmin()\nhighlight_year = counts.loc[min_idx, \"Ev\"]\n\n# Színek: alap szín, kiemelt év piros\ncolors = [\"tab:blue\"] * len(counts)\nhighlight_pos = counts.index[counts[\"Ev\"] == highlight_year][0]\ncolors[highlight_pos] = \"tab:red\"\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nbars = ax.bar(\n    counts[\"Ev\"].astype(str),\n    counts[\"Szamlak_szama\"],\n    color=colors\n)\n\nax.set_title(\"Számlák száma évente (kiemelve a legkevesebb számlás év)\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Számlák száma\")\n\n# Ezres tagolás a számlaszám tengelyen\nfrom matplotlib.ticker import FuncFormatter\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \")))\n\nresult = fig"}
{"timestamp": "2026-02-19T08:03:56.693438", "event": "question_run", "previous_question": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, és emeld ki azt az évet, amikor a legkevesebb számla volt!", "user_input": "Csak írd ki az évet", "gate_decision": "FOLLOWUP", "rewritten_question": "Melyik évben volt a legkevesebb számla az éves bontású adatok alapján?", "final_question": "Melyik évben volt a legkevesebb számla az éves bontású adatok alapján?", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndf_tmp = df.copy()\n\n# Kiállítás dátumának biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(\n    df_tmp[\"posting_date\"], errors=\"coerce\"\n)\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves számlaszám\nyear_counts = (\n    df_tmp\n    .groupby(\"Ev\")\n    .size()\n)\n\nif len(year_counts) == 0:\n    result = None\nelse:\n    min_count = year_counts.min()\n    min_years = year_counts[year_counts == min_count].index.tolist()\n    # Ha több év is van, amelyikben ugyanannyi a minimum, akkor a legkorábbi évet adjuk vissza\n    result = int(min(min_years))"}
{"timestamp": "2026-02-19T08:05:16.807098", "event": "question_run", "previous_question": "Melyik évben volt a legkevesebb számla az éves bontású adatok alapján?", "user_input": "Készíts egy oszlop diagramot ami minden évre külön mutatja az időben fizetett és késve fizetett számlák átlagos bruttó értékét!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Készíts egy oszlop diagramot ami minden évre külön mutatja az időben fizetett és késve fizetett számlák átlagos bruttó értékét!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nimport pandas as pd\nimport numpy as np\n\nMIN_DELAY_DAYS = 1  # késedelmes = legalább 1 nap\n\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető, kifizetett számlák\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Késés napokban\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Késedelmes flag\ndf_tmp[\"kesedelmes\"] = df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n\n# Csoportosítás: év + időben/késve\npivot = (\n    df_tmp\n    .groupby([\"Ev\", \"kesedelmes\"])[\"Brutto\"]\n    .mean()\n    .unstack(fill_value=np.nan)\n    .rename(columns={False: \"Idoben fizetett\", True: \"Kesve fizetett\"})\n)\n\n# Csak olyan évek, ahol legalább 1 érték van\npivot = pivot.dropna(how=\"all\", subset=[\"Idoben fizetett\", \"Kesve fizetett\"])\n\n# Diagram\nfig, ax = plt.subplots(figsize=(8,3))\n\nbar_width = 0.35\nx = np.arange(len(pivot.index))\n\nax.bar(\n    x - bar_width/2,\n    pivot[\"Idoben fizetett\"],\n    width=bar_width,\n    label=\"Időben fizetett\"\n)\nax.bar(\n    x + bar_width/2,\n    pivot[\"Kesve fizetett\"],\n    width=bar_width,\n    label=\"Késve fizetett\"\n)\n\nax.set_xticks(x)\nax.set_xticklabels(pivot.index.astype(str))\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Átlagos bruttó érték (Ft)\")\nax.set_title(\"Átlagos bruttó érték – időben vs. késve fizetett számlák (évenként)\")\nax.legend()\n\n# Pénzformátum az y tengelyen\nax.yaxis.set_major_formatter(\n    FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \"))\n)\n\nresult = fig"}
{"timestamp": "2026-02-19T08:06:24.591004", "event": "question_run", "previous_question": "Készíts egy oszlop diagramot ami minden évre külön mutatja az időben fizetett és késve fizetett számlák átlagos bruttó értékét!", "user_input": "Hány számla volt 2022-ben kiállítva?", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Hány számla volt 2022-ben kiállítva?", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nYEAR = 2022\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(\n    df_tmp[\"posting_date\"], errors=\"coerce\"\n)\n\ndf_filtered = df_tmp[\n    df_tmp[\"posting_date\"].dt.year == YEAR\n]\n\nresult = int(len(df_filtered))"}
{"timestamp": "2026-02-19T08:07:19.068066", "event": "question_run", "previous_question": "Hány számla volt 2022-ben kiállítva?", "user_input": "Mutasd egy táblázatban azt a 3 legnagyobb bruttó értékű számlát, amelyeknél több mint 30 napos fizetési késedelem volt!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Mutasd egy táblázatban azt a 3 legnagyobb bruttó értékű számlát, amelyeknél több mint 30 napos fizetési késedelem volt!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nimport pandas as pd\n\n# Paraméterek\nMIN_DELAY_DAYS = 31  # több mint 30 napos késedelem\nTOP_N = 3\n\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető, kifizetett számlák\ndf_tmp = df_tmp[\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna() &\n    df_tmp[\"Brutto\"].notna() &\n    df_tmp[\"customer_name\"].notna()\n].copy()\n\n# Késedelem napokban (kanonikus)\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Szűrés: több mint 30 napos késedelem\ndf_filtered = df_tmp[\n    df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n].copy()\n\n# 3 legnagyobb bruttó értékű számla\ndf_top = (\n    df_filtered\n    .nlargest(TOP_N, \"Brutto\")\n    .loc[:, [\"invoice_nr\", \"customer_name\", \"Brutto\", \"delay_days\"]]\n    .reset_index(drop=True)\n)\n\nresult = df_top"}
{"timestamp": "2026-02-20T12:49:16.635900", "event": "question_run", "previous_question": null, "user_input": "Mutasd táblázatban a 2023-as késve fizetett számlákat, amelyeknek a bruttó összege meghaladta a 3 000 000 Ft-ot!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Mutasd táblázatban a 2023-as késve fizetett számlákat, amelyeknek a bruttó összege meghaladta a 3 000 000 Ft-ot!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Paraméterek\nYEAR = 2023\nMIN_BRUTTO = 3_000_000\nMIN_DELAY_DAYS = 1\n\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető, kifizetett számlák\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\n# Csak 2023-as számlák\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].dt.year == YEAR\n].copy()\n\n# Késés napokban (kanonikus)\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Szűrés: késve fizetett (legalább 1 nap késés) és bruttó > 3M Ft (abs, visszajárók miatt)\ndf_tmp[\"Brutto_abs\"] = df_tmp[\"Brutto\"].abs()\ndf_filtered = df_tmp[\n    (df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS) &\n    (df_tmp[\"Brutto_abs\"] > MIN_BRUTTO)\n].copy()\n\n# Kimeneti táblázat (rendezés nélkül)\nresult = df_filtered[\n    [\n        \"invoice_nr\",\n        \"customer_name\",\n        \"posting_date\",\n        \"due_in_date\",\n        \"clear_date\",\n        \"Brutto\",\n        \"delay_days\"\n    ]\n].reset_index(drop=True)"}
{"timestamp": "2026-02-24T12:10:41.889640", "event": "question_run", "previous_question": null, "user_input": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummező biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves számlaszám aggregáció\ncounts = (\n    df_tmp\n    .groupby(\"Ev\")\n    .size()\n    .reset_index(name=\"Szamlak_szama\")\n)\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(counts[\"Ev\"].astype(str), counts[\"Szamlak_szama\"])\n\nax.set_title(\"Számlák száma évente\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Számlák száma\")\n\nresult = fig"}
{"timestamp": "2026-02-24T12:11:05.837556", "event": "question_run", "previous_question": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "user_input": "Melyik évben volt a legkevesebb számla?", "gate_decision": "FOLLOWUP", "rewritten_question": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, és emeld ki azt az évet, amikor a legkevesebb számla volt!", "final_question": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, és emeld ki azt az évet, amikor a legkevesebb számla volt!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummező biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves számlaszám aggregáció\ncounts = (\n    df_tmp\n    .groupby(\"Ev\")\n    .size()\n    .reset_index(name=\"Szamlak_szama\")\n)\n\n# Legkevesebb számlás év meghatározása\nmin_count = counts[\"Szamlak_szama\"].min()\nmin_years = counts[counts[\"Szamlak_szama\"] == min_count][\"Ev\"].tolist()\n\n# Színek: alap szín, minimum év(ek) kiemelve\ncolors = [\n    \"#d62728\" if year in min_years else \"#1f77b4\"\n    for year in counts[\"Ev\"]\n]\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nbars = ax.bar(\n    counts[\"Ev\"].astype(str),\n    counts[\"Szamlak_szama\"],\n    color=colors\n)\n\n# Kiemelés: annotáció a minimum oszlop(ok) fölé\nfor i, (year, value) in enumerate(zip(counts[\"Ev\"], counts[\"Szamlak_szama\"])):\n    if year in min_years:\n        ax.annotate(\n            \"Legkevesebb\",\n            xy=(i, value),\n            xytext=(0, 5),\n            textcoords=\"offset points\",\n            ha=\"center\",\n            va=\"bottom\",\n            fontsize=10,\n            color=\"#d62728\",\n            fontweight=\"bold\"\n        )\n\nax.set_title(\"Számlák száma éves bontásban\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Számlák száma\")\n\n# Ezres tagolás a számlaszám tengelyen\nfrom matplotlib.ticker import FuncFormatter\nax.yaxis.set_major_formatter(\n    FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \"))\n)\n\nresult = fig"}
{"timestamp": "2026-02-24T12:29:28.430758", "event": "question_run", "previous_question": null, "user_input": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, és emeld ki azt az évet, amikor a legkevesebb számla volt!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, és emeld ki azt az évet, amikor a legkevesebb számla volt!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Kiállítás dátumának biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(\n    df_tmp[\"posting_date\"], errors=\"coerce\"\n)\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves számlaszám aggregálása\ncounts = (\n    df_tmp\n    .groupby(\"Ev\")\n    .size()\n    .reset_index(name=\"Szamlak_szama\")\n)\n\n# Legkevesebb számlás év meghatározása\nmin_count = counts[\"Szamlak_szama\"].min()\nmin_years = counts[counts[\"Szamlak_szama\"] == min_count][\"Ev\"].tolist()\n\n# Színek: alap szín, minimum év(ek) kiemelve\nbase_color = \"#7fa2e6\"\nhighlight_color = \"#e65555\"\ncolors = [\n    highlight_color if year in min_years else base_color\n    for year in counts[\"Ev\"]\n]\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\n\nbars = ax.bar(\n    counts[\"Ev\"].astype(str),\n    counts[\"Szamlak_szama\"],\n    color=colors\n)\n\n# Tengelycímkék, cím\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Számlák száma\")\nax.set_title(\"Számlák száma éves bontásban (legkevesebb kiemelve)\")\n\n# Értékek kiírása az oszlopok tetejére\nfor bar, value in zip(bars, counts[\"Szamlak_szama\"]):\n    ax.text(\n        bar.get_x() + bar.get_width()/2,\n        bar.get_height(),\n        f\"{int(value):,}\".replace(\",\", \" \"),\n        ha=\"center\", va=\"bottom\", fontsize=9\n    )\n\nresult = fig"}
{"timestamp": "2026-02-24T12:30:36.331923", "event": "question_run", "previous_question": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, és emeld ki azt az évet, amikor a legkevesebb számla volt!", "user_input": "Melyik évben volt a legkevesebb számla?", "gate_decision": "FOLLOWUP", "rewritten_question": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, és emeld ki azt az évet, amikor a legkevesebb számla volt!", "final_question": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, és emeld ki azt az évet, amikor a legkevesebb számla volt!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummező biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves számlaszám aggregáció\ncounts = (\n    df_tmp\n    .groupby(\"Ev\")\n    .size()\n    .reset_index(name=\"Szamlak_szama\")\n)\n\n# Legkevesebb számlás év(ek) meghatározása\nmin_count = counts[\"Szamlak_szama\"].min()\nhighlight_mask = counts[\"Szamlak_szama\"] == min_count\n\n# Színek: alap szín, kiemelt év piros\ncolors = np.where(highlight_mask, \"#d62728\", \"#1f77b4\")\n\n# Diagram\nfig, ax = plt.subplots(figsize=(8,3))\nbars = ax.bar(\n    counts[\"Ev\"].astype(str),\n    counts[\"Szamlak_szama\"],\n    color=colors\n)\n\nax.set_title(\"Számlák száma éves bontásban (kiemelve a legkevesebb számlás év)\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Számlák száma\")\n\n# Ezres tagolás a tengelyen\nfrom matplotlib.ticker import FuncFormatter\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \")))\n\nresult = fig"}
{"timestamp": "2026-02-24T12:30:59.863941", "event": "question_run", "previous_question": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, és emeld ki azt az évet, amikor a legkevesebb számla volt!", "user_input": "Hány számla volt 2022-ben kiállítva?", "gate_decision": "FOLLOWUP", "rewritten_question": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, emeld ki azt az évet, amikor a legkevesebb számla volt, és add meg, hogy hány számla volt kiállítva 2022-ben!", "final_question": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, emeld ki azt az évet, amikor a legkevesebb számla volt, és add meg, hogy hány számla volt kiállítva 2022-ben!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummező biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves számlaszám aggregáció\ncounts = df_tmp.groupby(\"Ev\").size()\n\n# Legkevesebb számlás év(ek)\nmin_count = counts.min()\nmin_years = counts[counts == min_count].index.tolist()\n\n# 2022-es számlaszám\ncount_2022 = int(counts.get(2022, 0))\n\n# Diagram\nfig, ax = plt.subplots(figsize=(8,3))\n\nbars = ax.bar(counts.index.astype(str), counts.values, color=\"#4477AA\")\n\n# Kiemelés: legkevesebb számlás év(ek)\nfor i, year in enumerate(counts.index):\n    if year in min_years:\n        bars[i].set_color(\"#EE7733\")\n        bars[i].set_edgecolor(\"#222222\")\n        bars[i].set_linewidth(2)\n\nax.set_title(\"Számlák száma éves bontásban\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Számlák száma\")\n\n# Ezres tagolás a tengelyen\nfrom matplotlib.ticker import FuncFormatter\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \")))\n\n# Eredmény: diagram + 2022-es számlaszám\nresult = {\n    \"fig\": fig,\n    \"szamlak_2022_db\": count_2022\n}"}
{"timestamp": "2026-02-24T12:34:41.999529", "event": "question_run", "previous_question": null, "user_input": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, és emeld ki azt az évet, amikor a legkevesebb számla volt!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, és emeld ki azt az évet, amikor a legkevesebb számla volt!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Kiállítás dátumának biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(\n    df_tmp[\"posting_date\"], errors=\"coerce\"\n)\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves számlaszám aggregáció\ncounts = (\n    df_tmp\n    .groupby(\"Ev\")\n    .size()\n    .reset_index(name=\"Szamlak_szama\")\n)\n\n# Legkevesebb számlás év meghatározása\nmin_count = counts[\"Szamlak_szama\"].min()\nmin_years = counts[counts[\"Szamlak_szama\"] == min_count][\"Ev\"].tolist()\n\n# Színek: alap szín, minimum év(ek) kiemelve\nbase_color = \"#7fa2e6\"\nhighlight_color = \"#e84a5f\"\ncolors = [\n    highlight_color if year in min_years else base_color\n    for year in counts[\"Ev\"]\n]\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nbars = ax.bar(\n    counts[\"Ev\"].astype(str),\n    counts[\"Szamlak_szama\"],\n    color=colors\n)\n\n# Cím és tengelyek\nax.set_title(\"Számlák száma éves bontásban (legkevesebb kiemelve)\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Számlák száma\")\n\n# Értékek kiírása az oszlopok tetejére\nfor bar, value in zip(bars, counts[\"Szamlak_szama\"]):\n    ax.text(\n        bar.get_x() + bar.get_width()/2,\n        bar.get_height(),\n        f\"{int(value):,}\".replace(\",\", \" \"),\n        ha=\"center\", va=\"bottom\", fontsize=9\n    )\n\nresult = fig"}
{"timestamp": "2026-02-24T12:35:09.983079", "event": "question_run", "previous_question": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, és emeld ki azt az évet, amikor a legkevesebb számla volt!", "user_input": "A diagramban ne legyen rácsvonal! \n", "gate_decision": "FOLLOWUP", "rewritten_question": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, emeld ki azt az évet, amikor a legkevesebb számla volt, és a diagramban ne legyen rácsvonal!", "final_question": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, emeld ki azt az évet, amikor a legkevesebb számla volt, és a diagramban ne legyen rácsvonal!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummező biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves számlaszám\ncounts = df_tmp.groupby(\"Ev\").size()\n\nif len(counts) == 0:\n    fig, ax = plt.subplots(figsize=(8,3))\n    ax.text(0.5, 0.5, \"Nincs adat\", ha=\"center\", va=\"center\", fontsize=16)\n    ax.axis(\"off\")\n    result = fig\nelse:\n    min_year = counts.idxmin()\n    years = counts.index.astype(int)\n    values = counts.values.astype(int)\n    colors = [\"#d62728\" if y == min_year else \"#1f77b4\" for y in years]\n\n    fig, ax = plt.subplots(figsize=(8,3))\n    bars = ax.bar(years, values, color=colors)\n\n    # Kiemelés: legkevesebb számlás év\n    for bar, y in zip(bars, years):\n        if y == min_year:\n            bar.set_edgecolor(\"#222\")\n            bar.set_linewidth(2)\n\n    ax.set_title(\"Számlák száma éves bontásban\")\n    ax.set_xlabel(\"Év\")\n    ax.set_ylabel(\"Számlák száma\")\n\n    # Rácsvonalak kikapcsolása\n    ax.grid(False)\n\n    # Értékek kiírása az oszlopok tetejére\n    for bar in bars:\n        height = int(bar.get_height())\n        ax.annotate(f\"{height:,}\".replace(\",\", \" \"),\n                    xy=(bar.get_x() + bar.get_width() / 2, height),\n                    xytext=(0, 3),\n                    textcoords=\"offset points\",\n                    ha=\"center\", va=\"bottom\", fontsize=10)\n\n    result = fig"}
{"timestamp": "2026-02-24T12:36:50.859232", "event": "question_run", "previous_question": "Rajzolj egy oszlopdiagramot, amely éves bontásban mutatja a számlák számát, emeld ki azt az évet, amikor a legkevesebb számla volt, és a diagramban ne legyen rácsvonal!", "user_input": "Melyik évben volt legtöbb késve fizetett számla?", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Melyik évben volt legtöbb késve fizetett számla?", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nimport pandas as pd\n\n# Paraméter\nMIN_DELAY_DAYS = 1  # késedelmes = legalább 1 nap\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető, kifizetett számlák\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna()\n].copy()\n\n# Késés napokban (kanonikus)\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Késedelmes flag\ndf_tmp[\"kesedelmes\"] = df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Évenkénti késedelmes számlák száma\nstats = (\n    df_tmp[df_tmp[\"kesedelmes\"]]\n    .groupby(\"Ev\")\n    .size()\n)\n\nif len(stats) == 0:\n    result = None\nelse:\n    max_year = int(stats.idxmax())\n    result = max_year"}
{"timestamp": "2026-02-24T12:37:20.101977", "event": "question_run", "previous_question": "Melyik évben volt legtöbb késve fizetett számla?", "user_input": "Melyik ügyfélnek volt 2025-ben legtöbb késve fizetett számlája?", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Melyik ügyfélnek volt 2025-ben legtöbb késve fizetett számlája?", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nimport pandas as pd\n\nYEAR = 2025\nMIN_DELAY_DAYS = 1\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak 2025-ös, értelmezhető ügyfél, határidő és kifizetés\ndf_tmp = df_tmp[\n    (df_tmp[\"posting_date\"].dt.year == YEAR) &\n    df_tmp[\"customer_name\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna()\n].copy()\n\n# Késés napokban\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Késedelmes flag\ndf_tmp[\"kesedelmes\"] = df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n\n# Csak késedelmesek\ndf_delayed = df_tmp[df_tmp[\"kesedelmes\"]].copy()\n\nif len(df_delayed) == 0:\n    result = None\nelse:\n    counts = (\n        df_delayed\n        .groupby(\"customer_name\")\n        .size()\n    )\n    top_customer = str(counts.idxmax())\n    top_count = int(counts.max())\n    result = {\n        \"ugyfel\": top_customer,\n        \"kesedelmes_szamlak_szama\": top_count\n    }"}
{"timestamp": "2026-02-24T12:38:46.170861", "event": "question_run", "previous_question": "Melyik ügyfélnek volt 2025-ben legtöbb késve fizetett számlája?", "user_input": "Melyik évben volt a legkevesebb számla az éves bontású adatok alapján?", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Melyik évben volt a legkevesebb számla az éves bontású adatok alapján?", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nimport pandas as pd\n\ndf_tmp = df.copy()\n\n# Kiállítás dátumának biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(\n    df_tmp[\"posting_date\"], errors=\"coerce\"\n)\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves számlaszám\ncounts = df_tmp.groupby(\"Ev\").size()\n\nif len(counts) == 0:\n    result = None\nelse:\n    min_year = int(counts.idxmin())\n    result = min_year"}
{"timestamp": "2026-02-24T12:40:31.788818", "event": "question_run", "previous_question": "Melyik évben volt a legkevesebb számla az éves bontású adatok alapján?", "user_input": "Mutasd táblázatban a 2023-as késve fizetett számlákat, amelyeknek a bruttó összege meghaladta a 3 000 000 Ft-ot!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Mutasd táblázatban a 2023-as késve fizetett számlákat, amelyeknek a bruttó összege meghaladta a 3 000 000 Ft-ot!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nYEAR = 2023\nMIN_BRUTTO = 3_000_000\nMIN_DELAY_DAYS = 1\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].dt.year == YEAR\n].copy()\n\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\ndf_filtered = df_tmp[\n    (df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS) &\n    (df_tmp[\"Brutto\"] > MIN_BRUTTO)\n].copy()\n\nresult = df_filtered[\n    [\n        \"invoice_nr\",\n        \"customer_name\",\n        \"posting_date\",\n        \"due_in_date\",\n        \"clear_date\",\n        \"Brutto\",\n        \"delay_days\"\n    ]\n].reset_index(drop=True)"}
{"timestamp": "2026-02-24T14:56:29.108027", "event": "gate_decision", "previous_question": null, "user_input": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "gate_decision": "NEW", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-24T14:56:34.140517", "event": "question_run", "previous_question": null, "user_input": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Kiállítás dátumának biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(\n    df_tmp[\"posting_date\"], errors=\"coerce\"\n)\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves számlaszám aggregáció\ncounts = (\n    df_tmp\n    .groupby(\"Ev\")\n    .size()\n    .reset_index(name=\"Szamlak_szama\")\n)\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(counts[\"Ev\"].astype(str), counts[\"Szamlak_szama\"])\n\nax.set_title(\"Számlák száma évente\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Számlák száma\")\n\nresult = fig"}
{"timestamp": "2026-02-24T14:56:55.730305", "event": "gate_decision", "previous_question": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "user_input": "Ne legyen benne rácsvonal", "gate_decision": "FOLLOWUP", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-24T14:57:05.071278", "event": "question_run", "previous_question": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "user_input": "Ne legyen benne rácsvonal", "gate_decision": "FOLLOWUP", "rewritten_question": "Rajzolj egy oszlopdiagramot, amely éves szinten mutatja a számlák számát, és ne legyen benne rácsvonal!", "final_question": "Rajzolj egy oszlopdiagramot, amely éves szinten mutatja a számlák számát, és ne legyen benne rácsvonal!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Kiállítás dátumának biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(\n    df_tmp[\"posting_date\"], errors=\"coerce\"\n)\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves számlaszám aggregáció\ncounts = (\n    df_tmp\n    .groupby(\"Ev\")\n    .size()\n    .reset_index(name=\"Szamlak_szama\")\n)\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(counts[\"Ev\"].astype(str), counts[\"Szamlak_szama\"])\n\nax.set_title(\"Számlák száma évenként\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Számlák száma\")\n\n# Rácsvonalak eltávolítása\nax.grid(False)\n\nresult = fig"}
{"timestamp": "2026-02-24T14:57:16.195599", "event": "gate_decision", "previous_question": "Rajzolj egy oszlopdiagramot, amely éves szinten mutatja a számlák számát, és ne legyen benne rácsvonal!", "user_input": "Utolsó oszlop legyen piros", "gate_decision": "FOLLOWUP", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-24T14:57:24.532714", "event": "question_run", "previous_question": "Rajzolj egy oszlopdiagramot, amely éves szinten mutatja a számlák számát, és ne legyen benne rácsvonal!", "user_input": "Utolsó oszlop legyen piros", "gate_decision": "FOLLOWUP", "rewritten_question": "Rajzolj egy oszlopdiagramot, amely éves szinten mutatja a számlák számát rácsvonalak nélkül, és az utolsó oszlop legyen piros!", "final_question": "Rajzolj egy oszlopdiagramot, amely éves szinten mutatja a számlák számát rácsvonalak nélkül, és az utolsó oszlop legyen piros!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummező biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves számlaszám aggregáció\ncounts = (\n    df_tmp\n    .groupby(\"Ev\")\n    .size()\n    .reset_index(name=\"Szamlak_szama\")\n)\n\n# Oszlopdiagram színezés: utolsó oszlop piros, többi kék\ncolors = [\"#1f77b4\"] * len(counts)\nif len(colors) > 0:\n    colors[-1] = \"red\"\n\nfig, ax = plt.subplots(figsize=(8,3))\nbars = ax.bar(\n    counts[\"Ev\"].astype(str),\n    counts[\"Szamlak_szama\"].astype(int),\n    color=colors\n)\n\nax.set_title(\"Számlák száma évente\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Számlák száma\")\n\n# Rácsvonalak eltávolítása\nax.grid(False)\n\n# Tengelyen teljes szám, ezres tagolás\nfrom matplotlib.ticker import FuncFormatter\nax.yaxis.set_major_formatter(\n    FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \"))\n)\n\nresult = fig"}
{"timestamp": "2026-02-24T14:57:44.080653", "event": "gate_decision", "previous_question": "Rajzolj egy oszlopdiagramot, amely éves szinten mutatja a számlák számát rácsvonalak nélkül, és az utolsó oszlop legyen piros!", "user_input": "Melyik évben volt legtöbb számla kiállítva?", "gate_decision": "NEW", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-24T14:57:50.921724", "event": "question_run", "previous_question": "Rajzolj egy oszlopdiagramot, amely éves szinten mutatja a számlák számát rácsvonalak nélkül, és az utolsó oszlop legyen piros!", "user_input": "Melyik évben volt legtöbb számla kiállítva?", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Melyik évben volt legtöbb számla kiállítva?", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(\n    df_tmp[\"posting_date\"], errors=\"coerce\"\n)\n\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\ndf_tmp[\"ev\"] = df_tmp[\"posting_date\"].dt.year\n\ncounts = df_tmp.groupby(\"ev\").size()\n\nif len(counts) == 0:\n    result = None\nelse:\n    max_year = int(counts.idxmax())\n    max_count = int(counts.max())\n    result = {\"ev\": max_year, \"szamlak_szama\": max_count}"}
{"timestamp": "2026-02-24T14:58:36.097490", "event": "gate_decision", "previous_question": "Melyik évben volt legtöbb számla kiállítva?", "user_input": "Ja aja", "gate_decision": "UNCLEAR", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-24T15:09:43.447506", "event": "gate_decision", "previous_question": null, "user_input": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "gate_decision": "NEW", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-24T15:09:50.137693", "event": "question_run", "previous_question": null, "user_input": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummező biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves számlaszám aggregáció\ncounts = (\n    df_tmp\n    .groupby(\"Ev\")\n    .size()\n    .reset_index(name=\"Szamlak_szama\")\n)\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(counts[\"Ev\"].astype(str), counts[\"Szamlak_szama\"])\n\nax.set_title(\"Számlák száma évente\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Számlák száma\")\n\nfrom matplotlib.ticker import FuncFormatter\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \")))\n\nresult = fig"}
{"timestamp": "2026-02-24T15:11:12.228635", "event": "gate_decision", "previous_question": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "user_input": "Ne legyen benne rácsvonal\n", "gate_decision": "FOLLOWUP", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-24T15:11:19.924184", "event": "question_run", "previous_question": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "user_input": "Ne legyen benne rácsvonal\n", "gate_decision": "FOLLOWUP", "rewritten_question": "Rajzolj egy oszlopdiagramot, amely éves szinten mutatja a számlák számát, és ne legyen benne rácsvonal!", "final_question": "Rajzolj egy oszlopdiagramot, amely éves szinten mutatja a számlák számát, és ne legyen benne rácsvonal!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Kiállítás dátumának biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(\n    df_tmp[\"posting_date\"], errors=\"coerce\"\n)\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves számlaszám aggregáció\ncounts = (\n    df_tmp\n    .groupby(\"Ev\")\n    .size()\n    .reset_index(name=\"Szamlak_szama\")\n)\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(counts[\"Ev\"].astype(str), counts[\"Szamlak_szama\"])\n\nax.set_title(\"Számlák száma évenként\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Számlák száma\")\n\n# Rácsvonalak eltávolítása\nax.grid(False)\n\nresult = fig"}
{"timestamp": "2026-02-24T15:12:30.078491", "event": "gate_decision", "previous_question": "Rajzolj egy oszlopdiagramot, amely éves szinten mutatja a számlák számát, és ne legyen benne rácsvonal!", "user_input": "Rajzolj egy oszlop diagramot, ami éves bontásban mutatja a számlák számát, és egy vonal diagram mutassa, hogy a számlák hány százalék volt 10 napon túli késedelmes fizetésű az adott évben. \n", "gate_decision": "NEW", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-24T15:12:40.910234", "event": "question_run", "previous_question": "Rajzolj egy oszlopdiagramot, amely éves szinten mutatja a számlák számát, és ne legyen benne rácsvonal!", "user_input": "Rajzolj egy oszlop diagramot, ami éves bontásban mutatja a számlák számát, és egy vonal diagram mutassa, hogy a számlák hány százalék volt 10 napon túli késedelmes fizetésű az adott évben. \n", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Rajzolj egy oszlop diagramot, ami éves bontásban mutatja a számlák számát, és egy vonal diagram mutassa, hogy a számlák hány százalék volt 10 napon túli késedelmes fizetésű az adott évben.", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nimport pandas as pd\n\n# Paraméterek\nMIN_DELAY_DAYS = 10\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető kiállítási dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Késés napokban (csak ahol van határidő és kifizetés)\nmask_delay = df_tmp[\"due_in_date\"].notna() & df_tmp[\"clear_date\"].notna()\ndf_tmp[\"delay_days\"] = pd.NA\ndf_tmp.loc[mask_delay, \"delay_days\"] = kesedelmes_napok(\n    df_tmp.loc[mask_delay, \"due_in_date\"],\n    df_tmp.loc[mask_delay, \"clear_date\"]\n)\n\n# Késedelmes flag (legalább 10 nap)\ndf_tmp[\"kesedelmes\"] = (df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS)\n\n# Aggregáció év szerint\nagg = (\n    df_tmp\n    .groupby(\"Ev\")\n    .agg(\n        szamlak_szama = (\"invoice_id\", \"count\"),\n        kesedelmes_db = (\"kesedelmes\", \"sum\")\n    )\n    .reset_index()\n)\n\nagg[\"kesedelmes_pct\"] = agg[\"kesedelmes_db\"] / agg[\"szamlak_szama\"] * 100\n\n# Diagram\nfig, ax1 = plt.subplots(figsize=(8,3))\n\n# Oszlopdiagram: számlák száma\nbars = ax1.bar(\n    agg[\"Ev\"].astype(str),\n    agg[\"szamlak_szama\"],\n    color=\"#4B8BBE\",\n    alpha=0.7,\n    label=\"Számlák száma\"\n)\nax1.set_ylabel(\"Számlák száma\")\nax1.set_xlabel(\"Év\")\nax1.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \")))\n\n# Vonaldiagram: késedelmes arány\nax2 = ax1.twinx()\nax2.plot(\n    agg[\"Ev\"].astype(str),\n    agg[\"kesedelmes_pct\"],\n    color=\"#E23D28\",\n    marker=\"o\",\n    label=\"10 napon túli késedelmes fizetés (%)\"\n)\nax2.set_ylabel(\"10 napon túli késedelmes fizetés (%)\")\nax2.set_ylim(bottom=0)\n\n# Cím és jelmagyarázat\nfig.suptitle(\"Éves számlaszám és 10 napon túli késedelmes fizetés aránya\")\nlines_labels = [ax.get_legend_handles_labels() for ax in [ax1, ax2]]\nlines, labels = [sum(lol, []) for lol in zip(*lines_labels)]\nfig.legend(lines, labels, loc=\"upper left\", bbox_to_anchor=(0.12, 0.98))\n\nresult = fig"}
{"timestamp": "2026-02-24T15:15:23.874387", "event": "gate_decision", "previous_question": "Rajzolj egy oszlop diagramot, ami éves bontásban mutatja a számlák számát, és egy vonal diagram mutassa, hogy a számlák hány százalék volt 10 napon túli késedelmes fizetésű az adott évben.", "user_input": "Rajzolj egy voonaldiagramot, ami a 2023-as számlákat havi bontásban mutatja, hogy az adott hónapban kiállított számlá hány százaléka volt 10 napon túl kifizetve !", "gate_decision": "NEW", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-24T15:15:33.629764", "event": "question_run", "previous_question": "Rajzolj egy oszlop diagramot, ami éves bontásban mutatja a számlák számát, és egy vonal diagram mutassa, hogy a számlák hány százalék volt 10 napon túli késedelmes fizetésű az adott évben.", "user_input": "Rajzolj egy voonaldiagramot, ami a 2023-as számlákat havi bontásban mutatja, hogy az adott hónapban kiállított számlá hány százaléka volt 10 napon túl kifizetve !", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Rajzolj egy voonaldiagramot, ami a 2023-as számlákat havi bontásban mutatja, hogy az adott hónapban kiállított számlá hány százaléka volt 10 napon túl kifizetve !", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nYEAR = 2023\nMIN_DELAY_DAYS = 10\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    (df_tmp[\"posting_date\"].dt.year == YEAR)\n].copy()\n\ndf_tmp[\"Honap\"] = df_tmp[\"posting_date\"].dt.to_period(\"M\")\n\nrecords = []\n\nfor honap, sub in df_tmp.groupby(\"Honap\"):\n    total = len(sub)\n    if total == 0:\n        continue\n\n    paid = sub[\n        sub[\"clear_date\"].notna() &\n        sub[\"due_in_date\"].notna()\n    ].copy()\n\n    if len(paid) == 0:\n        pct_delayed = 0.0\n    else:\n        paid[\"delay_days\"] = kesedelmes_napok(\n            paid[\"due_in_date\"],\n            paid[\"clear_date\"]\n        )\n        delayed = paid[paid[\"delay_days\"] > MIN_DELAY_DAYS]\n        pct_delayed = len(delayed) / total * 100\n\n    records.append({\n        \"Honap\": honap.to_timestamp(how=\"start\"),\n        \"Keses_pct\": float(pct_delayed)\n    })\n\ndf_plot = pd.DataFrame(records)\n\nfig, ax = plt.subplots(figsize=(8,3))\nax.plot(\n    df_plot[\"Honap\"],\n    df_plot[\"Keses_pct\"],\n    marker=\"o\"\n)\nax.set_title(\"2023-as számlák: 10 napon túl kifizetettek aránya – havi bontásban\")\nax.set_ylabel(\"%\")\nax.set_xlabel(\"Hónap\")\n\nresult = fig"}
{"timestamp": "2026-02-24T15:15:53.475990", "event": "gate_decision", "previous_question": "Rajzolj egy voonaldiagramot, ami a 2023-as számlákat havi bontásban mutatja, hogy az adott hónapban kiállított számlá hány százaléka volt 10 napon túl kifizetve !", "user_input": "Az y tengely induljon 0-tól", "gate_decision": "FOLLOWUP", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-24T15:16:04.911335", "event": "question_run", "previous_question": "Rajzolj egy voonaldiagramot, ami a 2023-as számlákat havi bontásban mutatja, hogy az adott hónapban kiállított számlá hány százaléka volt 10 napon túl kifizetve !", "user_input": "Az y tengely induljon 0-tól", "gate_decision": "FOLLOWUP", "rewritten_question": "Rajzolj egy vonaldiagramot, amely a 2023-as számlák esetében havi bontásban mutatja, hogy az adott hónapban kiállított számlák hány százaléka volt 10 napon túl kifizetve, és az y tengely 0-tól induljon!", "final_question": "Rajzolj egy vonaldiagramot, amely a 2023-as számlák esetében havi bontásban mutatja, hogy az adott hónapban kiállított számlák hány százaléka volt 10 napon túl kifizetve, és az y tengely 0-tól induljon!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nYEAR = 2023\nMIN_DELAY_DAYS = 10\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak 2023-as számlák, ahol van kiállítási dátum\ndf_tmp = df_tmp[\n    (df_tmp[\"posting_date\"].dt.year == YEAR) &\n    df_tmp[\"posting_date\"].notna()\n].copy()\n\n# Hónap képzése\ndf_tmp[\"Honap\"] = df_tmp[\"posting_date\"].dt.to_period(\"M\").dt.to_timestamp()\n\nrecords = []\n\nfor honap, sub in df_tmp.groupby(\"Honap\"):\n    total = len(sub)\n    if total == 0:\n        continue\n\n    # Csak ahol van határidő és kifizetési dátum\n    paid = sub[\n        sub[\"due_in_date\"].notna() &\n        sub[\"clear_date\"].notna()\n    ].copy()\n\n    if len(paid) == 0:\n        pct_delayed = 0.0\n    else:\n        paid[\"delay_days\"] = kesedelmes_napok(\n            paid[\"due_in_date\"],\n            paid[\"clear_date\"]\n        )\n        delayed = paid[paid[\"delay_days\"] > MIN_DELAY_DAYS]\n        pct_delayed = len(delayed) / total * 100\n\n    records.append({\n        \"Honap\": honap,\n        \"Keses_pct\": float(pct_delayed)\n    })\n\ndf_plot = pd.DataFrame(records)\n\nfig, ax = plt.subplots(figsize=(8,3))\nax.plot(\n    df_plot[\"Honap\"],\n    df_plot[\"Keses_pct\"],\n    marker=\"o\"\n)\nax.set_title(\"10 napon túl kifizetett számlák aránya – 2023, havi bontás\")\nax.set_xlabel(\"Hónap\")\nax.set_ylabel(\"%\")\nax.set_ylim(bottom=0)\n\nresult = fig"}
{"timestamp": "2026-02-24T15:17:01.355711", "event": "gate_decision", "previous_question": "Rajzolj egy vonaldiagramot, amely a 2023-as számlák esetében havi bontásban mutatja, hogy az adott hónapban kiállított számlák hány százaléka volt 10 napon túl kifizetve, és az y tengely 0-tól induljon!", "user_input": "Válogasd le a 2023 februári számlák közül azokat egy táblázatba, amelyek 10 napon túl lettek kifizetve", "gate_decision": "NEW", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-24T15:17:06.068776", "event": "question_run", "previous_question": "Rajzolj egy vonaldiagramot, amely a 2023-as számlák esetében havi bontásban mutatja, hogy az adott hónapban kiállított számlák hány százaléka volt 10 napon túl kifizetve, és az y tengely 0-tól induljon!", "user_input": "Válogasd le a 2023 februári számlák közül azokat egy táblázatba, amelyek 10 napon túl lettek kifizetve", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Válogasd le a 2023 februári számlák közül azokat egy táblázatba, amelyek 10 napon túl lettek kifizetve", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nimport pandas as pd\n\n# Paraméterek\nYEAR = 2023\nMONTH = 2\nMIN_DELAY_DAYS = 10\n\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető, kifizetett számlák\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna()\n].copy()\n\n# Csak 2023 februári számlák\ndf_tmp = df_tmp[\n    (df_tmp[\"posting_date\"].dt.year == YEAR) &\n    (df_tmp[\"posting_date\"].dt.month == MONTH)\n].copy()\n\n# Késés napokban\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Szűrés: legalább 10 napos késedelem\ndf_filtered = df_tmp[\n    df_tmp[\"delay_days\"] > MIN_DELAY_DAYS\n].copy()\n\nresult = df_filtered.reset_index(drop=True)"}
{"timestamp": "2026-02-24T15:17:43.813013", "event": "gate_decision", "previous_question": "Válogasd le a 2023 februári számlák közül azokat egy táblázatba, amelyek 10 napon túl lettek kifizetve", "user_input": "Csak a számlaszámot, az ügyfél nevét és a bruttó összeget mutasd! ", "gate_decision": "FOLLOWUP", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-24T15:17:56.293690", "event": "question_run", "previous_question": "Válogasd le a 2023 februári számlák közül azokat egy táblázatba, amelyek 10 napon túl lettek kifizetve", "user_input": "Csak a számlaszámot, az ügyfél nevét és a bruttó összeget mutasd! ", "gate_decision": "FOLLOWUP", "rewritten_question": "Készíts egy táblázatot a 2023 februári számlák közül csak azoknak a számlaszámával, ügyfél nevével és bruttó összegével, amelyeket 10 napon túl fizettek ki!", "final_question": "Készíts egy táblázatot a 2023 februári számlák közül csak azoknak a számlaszámával, ügyfél nevével és bruttó összegével, amelyeket 10 napon túl fizettek ki!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nimport pandas as pd\n\n# Paraméterek\nYEAR = 2023\nMONTH = 2\nMIN_DELAY_DAYS = 10\n\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető, kifizetett számlák\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna() &\n    df_tmp[\"customer_name\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\n# Csak 2023 februári számlák\ndf_tmp = df_tmp[\n    (df_tmp[\"posting_date\"].dt.year == YEAR) &\n    (df_tmp[\"posting_date\"].dt.month == MONTH)\n].copy()\n\n# Késés napokban\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Szűrés: legalább 10 napos késedelem\ndf_filtered = df_tmp[\n    df_tmp[\"delay_days\"] > MIN_DELAY_DAYS\n].copy()\n\n# Kimeneti táblázat\nresult = df_filtered[\n    [\"invoice_nr\", \"customer_name\", \"Brutto\"]\n].reset_index(drop=True)"}
{"timestamp": "2026-02-24T15:18:26.398955", "event": "gate_decision", "previous_question": "Készíts egy táblázatot a 2023 februári számlák közül csak azoknak a számlaszámával, ügyfél nevével és bruttó összegével, amelyeket 10 napon túl fizettek ki!", "user_input": "Csak a számlaszámot a Danube Digital 72 számláit mutasd ezek közül! ", "gate_decision": "FOLLOWUP", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-24T15:18:36.739499", "event": "question_run", "previous_question": "Készíts egy táblázatot a 2023 februári számlák közül csak azoknak a számlaszámával, ügyfél nevével és bruttó összegével, amelyeket 10 napon túl fizettek ki!", "user_input": "Csak a számlaszámot a Danube Digital 72 számláit mutasd ezek közül! ", "gate_decision": "FOLLOWUP", "rewritten_question": "Melyek azoknak a 2023 februárjában 10 napon túl kifizetett számláknak a számlaszámai, amelyek a Danube Digital 72 ügyfélhez tartoznak?", "final_question": "Melyek azoknak a 2023 februárjában 10 napon túl kifizetett számláknak a számlaszámai, amelyek a Danube Digital 72 ügyfélhez tartoznak?", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nimport pandas as pd\n\n# Paraméterek\nYEAR = 2023\nMONTH = 2\nMIN_DELAY_DAYS = 10\nQUERY_NAME = \"Danube Digital 72\"\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető, kifizetett számlák\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna() &\n    df_tmp[\"customer_name\"].notna()\n].copy()\n\n# Entitásfeloldás (KÖTELEZŐ)\ncandidates = sorted(df_tmp[\"customer_name\"].dropna().unique().tolist())\nresolved_name = resolve_entity(QUERY_NAME, candidates)\n\nif resolved_name is None:\n    result = {\n        \"message\": \"Nem található a megadott névhez illeszkedő ügyfél.\",\n        \"keresett_nev\": QUERY_NAME,\n        \"hasonlo_nevek\": candidates[:10]\n    }\nelse:\n    # Csak 2023 februári számlák, adott ügyfél\n    df_feb = df_tmp[\n        (df_tmp[\"posting_date\"].dt.year == YEAR) &\n        (df_tmp[\"posting_date\"].dt.month == MONTH) &\n        (df_tmp[\"customer_name\"] == resolved_name)\n    ].copy()\n\n    # Késés napokban\n    df_feb[\"delay_days\"] = kesedelmes_napok(\n        df_feb[\"due_in_date\"],\n        df_feb[\"clear_date\"]\n    )\n\n    # Szűrés: legalább 10 napos késedelem\n    df_filtered = df_feb[\n        df_feb[\"delay_days\"] > MIN_DELAY_DAYS\n    ]\n\n    # Csak a számlaszámok listája\n    result = df_filtered[\"invoice_nr\"].dropna().astype(str).tolist()"}
{"timestamp": "2026-02-25T08:30:07.440172", "event": "gate_decision", "previous_question": null, "user_input": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "gate_decision": "NEW", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-25T08:30:15.928497", "event": "question_run", "previous_question": null, "user_input": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummező biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\n\n# Csak értelmezhető dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Éves számlaszám aggregáció\ncounts = (\n    df_tmp\n    .groupby(\"Ev\")\n    .size()\n    .reset_index(name=\"Szamlak_szama\")\n)\n\n# Oszlopdiagram\nfig, ax = plt.subplots(figsize=(8,3))\nax.bar(counts[\"Ev\"].astype(str), counts[\"Szamlak_szama\"])\n\nax.set_title(\"Számlák száma évente\")\nax.set_xlabel(\"Év\")\nax.set_ylabel(\"Számlák száma\")\n\n# Ezres tagolás a számlaszám tengelyen\nfrom matplotlib.ticker import FuncFormatter\nax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \")))\n\nresult = fig"}
{"timestamp": "2026-02-25T08:30:30.038711", "event": "gate_decision", "previous_question": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "user_input": "Melyik ügyfélnek volt 2025-ben legtöbb késve fizetett számlája?", "gate_decision": "NEW", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-25T08:30:35.043457", "event": "question_run", "previous_question": "Rajzolj egy oszlop diagramot, ami éves szintem mutatja a számlák számát!", "user_input": "Melyik ügyfélnek volt 2025-ben legtöbb késve fizetett számlája?", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Melyik ügyfélnek volt 2025-ben legtöbb késve fizetett számlája?", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nimport pandas as pd\n\nYEAR = 2025\nMIN_DELAY_DAYS = 1\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\ndf_tmp = df_tmp[\n    (df_tmp[\"posting_date\"].dt.year == YEAR) &\n    df_tmp[\"customer_name\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna()\n].copy()\n\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\ndf_tmp[\"kesedelmes\"] = df_tmp[\"delay_days\"] >= MIN_DELAY_DAYS\n\ncounts = (\n    df_tmp[df_tmp[\"kesedelmes\"]]\n    .groupby(\"customer_name\")\n    .size()\n    .sort_values(ascending=False)\n)\n\nif len(counts) == 0:\n    result = None\nelse:\n    top_customer = str(counts.index[0])\n    top_count = int(counts.iloc[0])\n    result = {\n        \"ugyfel\": top_customer,\n        \"kesve_fizetett_szamlak_szama\": top_count\n    }"}
{"timestamp": "2026-02-25T09:09:08.435856", "event": "gate_decision", "previous_question": null, "user_input": "Rajzolj egy oszlop diagramot, ami éves bontásban mutatja a számlák számát, és egy vonal diagram mutassa, hogy a számlák hány százalék volt 10 napon túli késedelmes fizetésű az adott évben.", "gate_decision": "NEW", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-25T09:09:20.416307", "event": "question_run", "previous_question": null, "user_input": "Rajzolj egy oszlop diagramot, ami éves bontásban mutatja a számlák számát, és egy vonal diagram mutassa, hogy a számlák hány százalék volt 10 napon túli késedelmes fizetésű az adott évben.", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Rajzolj egy oszlop diagramot, ami éves bontásban mutatja a számlák számát, és egy vonal diagram mutassa, hogy a számlák hány százalék volt 10 napon túli késedelmes fizetésű az adott évben.", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nimport pandas as pd\n\n# Paraméterek\nMIN_DELAY_DAYS = 10\n\n# Másolat az adatokból\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető kiállítási dátum\ndf_tmp = df_tmp[df_tmp[\"posting_date\"].notna()].copy()\n\n# Év képzése\ndf_tmp[\"Ev\"] = df_tmp[\"posting_date\"].dt.year\n\n# Késés napokban (csak ahol van határidő és kifizetés)\nmask_delay = df_tmp[\"due_in_date\"].notna() & df_tmp[\"clear_date\"].notna()\ndf_tmp[\"delay_days\"] = pd.NA\ndf_tmp.loc[mask_delay, \"delay_days\"] = kesedelmes_napok(\n    df_tmp.loc[mask_delay, \"due_in_date\"],\n    df_tmp.loc[mask_delay, \"clear_date\"]\n)\n\n# Késedelmes flag (csak ahol értelmezhető)\ndf_tmp[\"kesedelmes\"] = False\ndf_tmp.loc[mask_delay, \"kesedelmes\"] = (\n    df_tmp.loc[mask_delay, \"delay_days\"] >= MIN_DELAY_DAYS\n)\n\n# Aggregáció: év szerint\nagg = (\n    df_tmp\n    .groupby(\"Ev\")\n    .agg(\n        szamlak_szama=(\"invoice_id\", \"count\"),\n        kesedelmes_szamlak_szama=(\"kesedelmes\", \"sum\")\n    )\n    .reset_index()\n)\n\nagg[\"kesedelmes_arany_pct\"] = (\n    agg[\"kesedelmes_szamlak_szama\"] / agg[\"szamlak_szama\"] * 100\n)\n\n# Diagram\nfig, ax1 = plt.subplots(figsize=(8,3))\n\n# Oszlopdiagram: számlák száma\nax1.bar(\n    agg[\"Ev\"],\n    agg[\"szamlak_szama\"],\n    color=\"#4B8BBE\",\n    alpha=0.7,\n    label=\"Számlák száma\"\n)\nax1.set_ylabel(\"Számlák száma\")\nax1.set_xlabel(\"Év\")\nax1.yaxis.set_major_formatter(\n    FuncFormatter(lambda x, _: f\"{int(x):,}\".replace(\",\", \" \"))\n)\n\n# Vonaldiagram: késedelmes arány\nax2 = ax1.twinx()\nax2.plot(\n    agg[\"Ev\"],\n    agg[\"kesedelmes_arany_pct\"],\n    color=\"#E23D28\",\n    marker=\"o\",\n    label=\"10 napon túli késedelmes arány (%)\"\n)\nax2.set_ylabel(\"10 napon túli késedelmes arány (%)\")\nax2.set_ylim(bottom=0)\n\n# Cím és legendák\nax1.set_title(\"Éves számlaszám és 10 napon túli késedelmes fizetés aránya\")\nlines_1, labels_1 = ax1.get_legend_handles_labels()\nlines_2, labels_2 = ax2.get_legend_handles_labels()\nax2.legend(lines_1 + lines_2, labels_1 + labels_2, loc=\"upper left\")\n\nresult = fig"}
{"timestamp": "2026-02-25T09:09:44.516808", "event": "gate_decision", "previous_question": "Rajzolj egy oszlop diagramot, ami éves bontásban mutatja a számlák számát, és egy vonal diagram mutassa, hogy a számlák hány százalék volt 10 napon túli késedelmes fizetésű az adott évben.", "user_input": "Rajzolj egy voonaldiagramot, ami a 2023-as számlákat havi bontásban mutatja, hogy az adott hónapban kiállított számlá hány százaléka volt 10 napon túl kifizetve !", "gate_decision": "NEW", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-25T09:09:50.091475", "event": "question_run", "previous_question": "Rajzolj egy oszlop diagramot, ami éves bontásban mutatja a számlák számát, és egy vonal diagram mutassa, hogy a számlák hány százalék volt 10 napon túli késedelmes fizetésű az adott évben.", "user_input": "Rajzolj egy voonaldiagramot, ami a 2023-as számlákat havi bontásban mutatja, hogy az adott hónapban kiállított számlá hány százaléka volt 10 napon túl kifizetve !", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Rajzolj egy voonaldiagramot, ami a 2023-as számlákat havi bontásban mutatja, hogy az adott hónapban kiállított számlá hány százaléka volt 10 napon túl kifizetve !", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nYEAR = 2023\nMIN_DELAY_DAYS = 10\n\ndf_tmp = df.copy()\n\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    (df_tmp[\"posting_date\"].dt.year == YEAR)\n].copy()\n\ndf_tmp[\"Honap\"] = df_tmp[\"posting_date\"].dt.to_period(\"M\")\n\nrecords = []\n\nfor honap, sub in df_tmp.groupby(\"Honap\"):\n    total = len(sub)\n    if total == 0:\n        continue\n\n    paid = sub[\n        sub[\"clear_date\"].notna() &\n        sub[\"due_in_date\"].notna()\n    ].copy()\n\n    if len(paid) == 0:\n        pct_delayed = 0.0\n    else:\n        paid[\"delay_days\"] = kesedelmes_napok(\n            paid[\"due_in_date\"],\n            paid[\"clear_date\"]\n        )\n        delayed = paid[paid[\"delay_days\"] > MIN_DELAY_DAYS]\n        pct_delayed = len(delayed) / total * 100\n\n    records.append({\n        \"Honap\": honap.to_timestamp(how=\"start\"),\n        \"Keses_pct\": float(pct_delayed)\n    })\n\ndf_plot = pd.DataFrame(records)\n\nfig, ax = plt.subplots(figsize=(8,3))\nax.plot(\n    df_plot[\"Honap\"],\n    df_plot[\"Keses_pct\"],\n    marker=\"o\"\n)\nax.set_title(\"10 napon túl kifizetett számlák aránya – 2023 havi bontásban\")\nax.set_ylabel(\"%\")\nax.set_xlabel(\"Hónap\")\n\nresult = fig"}
{"timestamp": "2026-02-25T09:10:15.867063", "event": "gate_decision", "previous_question": "Rajzolj egy voonaldiagramot, ami a 2023-as számlákat havi bontásban mutatja, hogy az adott hónapban kiállított számlá hány százaléka volt 10 napon túl kifizetve !", "user_input": "Válogasd le a 2023 februári számlák közül azokat egy táblázatba, amelyek 10 napon túl lettek kifizetve", "gate_decision": "NEW", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-25T09:10:20.924229", "event": "question_run", "previous_question": "Rajzolj egy voonaldiagramot, ami a 2023-as számlákat havi bontásban mutatja, hogy az adott hónapban kiállított számlá hány százaléka volt 10 napon túl kifizetve !", "user_input": "Válogasd le a 2023 februári számlák közül azokat egy táblázatba, amelyek 10 napon túl lettek kifizetve", "gate_decision": "NEW", "rewritten_question": null, "final_question": "Válogasd le a 2023 februári számlák közül azokat egy táblázatba, amelyek 10 napon túl lettek kifizetve", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Paraméterek\nYEAR = 2023\nMONTH = 2\nMIN_DELAY_DAYS = 10\n\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető, kifizetett számlák\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna()\n].copy()\n\n# Csak 2023 februári számlák\ndf_tmp = df_tmp[\n    (df_tmp[\"posting_date\"].dt.year == YEAR) &\n    (df_tmp[\"posting_date\"].dt.month == MONTH)\n].copy()\n\n# Késés napokban\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Szűrés: legalább 10 napos késedelem\ndf_filtered = df_tmp[\n    df_tmp[\"delay_days\"] > MIN_DELAY_DAYS\n].copy()\n\nresult = df_filtered.reset_index(drop=True)"}
{"timestamp": "2026-02-25T09:11:03.549982", "event": "gate_decision", "previous_question": "Válogasd le a 2023 februári számlák közül azokat egy táblázatba, amelyek 10 napon túl lettek kifizetve", "user_input": "Csak a számlaszámot, ügyfél nevét, bruttó összeget és a késés napját mutasd!", "gate_decision": "FOLLOWUP", "app_name": "Számla elemzés"}
{"timestamp": "2026-02-25T09:11:11.110439", "event": "question_run", "previous_question": "Válogasd le a 2023 februári számlák közül azokat egy táblázatba, amelyek 10 napon túl lettek kifizetve", "user_input": "Csak a számlaszámot, ügyfél nevét, bruttó összeget és a késés napját mutasd!", "gate_decision": "FOLLOWUP", "rewritten_question": "Készíts egy táblázatot a 2023 februári számlák közül azokról, amelyeket 10 napon túl fizettek ki, és csak a számlaszámot, ügyfél nevét, bruttó összeget és a késés napját mutasd!", "final_question": "Készíts egy táblázatot a 2023 februári számlák közül azokról, amelyeket 10 napon túl fizettek ki, és csak a számlaszámot, ügyfél nevét, bruttó összeget és a késés napját mutasd!", "app_name": "Számla elemzés", "generated_code": "import warnings; warnings.filterwarnings(\"ignore\")\nfrom matplotlib_theme import apply_default_theme\napply_default_theme()\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Paraméterek\nYEAR = 2023\nMONTH = 2\nMIN_DELAY_DAYS = 10\n\ndf_tmp = df.copy()\n\n# Dátummezők biztos kezelése\ndf_tmp[\"posting_date\"] = pd.to_datetime(df_tmp[\"posting_date\"], errors=\"coerce\")\ndf_tmp[\"due_in_date\"] = pd.to_datetime(df_tmp[\"due_in_date\"], errors=\"coerce\")\ndf_tmp[\"clear_date\"] = pd.to_datetime(df_tmp[\"clear_date\"], errors=\"coerce\")\n\n# Csak értelmezhető, kifizetett számlák\ndf_tmp = df_tmp[\n    df_tmp[\"posting_date\"].notna() &\n    df_tmp[\"due_in_date\"].notna() &\n    df_tmp[\"clear_date\"].notna() &\n    df_tmp[\"customer_name\"].notna() &\n    df_tmp[\"Brutto\"].notna()\n].copy()\n\n# Csak 2023 februári számlák\ndf_tmp = df_tmp[\n    (df_tmp[\"posting_date\"].dt.year == YEAR) &\n    (df_tmp[\"posting_date\"].dt.month == MONTH)\n].copy()\n\n# Késés napokban\ndf_tmp[\"delay_days\"] = kesedelmes_napok(\n    df_tmp[\"due_in_date\"],\n    df_tmp[\"clear_date\"]\n)\n\n# Szűrés: legalább 10 napos késés\ndf_filtered = df_tmp[\n    df_tmp[\"delay_days\"] > MIN_DELAY_DAYS\n].copy()\n\n# Kimeneti táblázat\nresult = df_filtered[\n    [\"invoice_nr\", \"customer_name\", \"Brutto\", \"delay_days\"]\n].reset_index(drop=True)"}
